<!-- Tool to visualize telescope FoV and mosaic grid. Jarmo Ruuth, 2018-2020 -->
<!DOCTYPE HTML>
<html lang = "en">
<head>
<link rel="icon" type="image/png" sizes="16x16" href="AM-favicon.png">
<!-- include Aladin Lite CSS file in the head section of your page -->
<link rel="stylesheet" href="https://aladin.u-strasbg.fr/AladinLite/api/v2/latest/aladin.min.css" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>

.header {
  background: lightgray;
}

.h2text {
  padding-bottom: 20px;
  text-align: left;
  margin-left: 80px;
}

.banner {
  padding: 5px;
  margin: 5px;
  background: whitesmoke;
  color: darkred;
}

.flex-container-top {
  display: flex;
  flex-direction: row;
  background: white;
}

.flex-container-top > div {
  margin: 2px;
  padding: 2px;
}

.flex-container-top2 {
  display: flex;
  flex-direction: row;
  background: white;
}

.flex-container-top2 > div {
  margin: 2px;
  padding: 2px;
}

.flex-container {
  display: flex;
  flex-direction: row;
  background: white;
}

.flex-container > div {
  margin: 2px;
  padding: 2px;
}

p {
    margin: 0px;
    padding: 0px;
}

.footer {
  padding: 10px;
  background: whitesmoke;
}

/* Dropdown Button */
.dropbtn {
  background-color: lightgray;
  color: white;
  padding: 16px;
  font-size: 16px;
  border: none;
  padding: 5px;
  margin: 5px;
}

/* The container <div> - needed to position the dropdown content */
.dropdown {
  position: relative;
  display: inline-block;
}

/* Dropdown Content (Hidden by Default) */
.dropdown-content {
  display: none;
  position: absolute;
  background-color: #f1f1f1;
  min-width: 160px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  z-index: 1;
}

/* Links inside the dropdown */
.dropdown-content a {
  color: black;
  padding: 12px 16px;
  text-decoration: none;
  display: block;
}

/* Change color of dropdown links on hover */
.dropdown-content a:hover {background-color: #ddd;}

/* Show the dropdown menu on hover */
.dropdown:hover .dropdown-content {display: block;}

/* Change the background color of the dropdown button when the dropdown content is shown */
.dropdown:hover .dropbtn {background-color: #3e8e41;}
</style>
    <title>AstroMosaic</title>
    <meta charset = "UTF-8" />
</head>

<body>
<script type="text/javascript" src="https://code.jquery.com/jquery-1.12.1.min.js" charset="utf-8"></script>
<script type="text/javascript" src="https://aladin.u-strasbg.fr/AladinLite/api/v2/latest/aladin.min.js" charset="utf-8"></script>

<div class="header">
    <div class="dropdown">
        <button class="dropbtn"><img src="menu-24px.svg" alt="Home" height="16"></button>
        <div class="dropdown-content">
            <a href="AstroImageTools.html">Home</a>
            <a href="AstroMosaicInfo.html">Astro Mosaic</a>
            <a href="AutoIntegrateInfo.html">AutoIntegrate</a>
            <a href="DownloadFitInfo.html">Download .fit</a>
            <a href="FitsPyInfo.html">FITS utility</a>
        </div>
    </div>
    <div class="h2text">
        <h2 id="astro_mosaic_title" >Astro Mosaic Telescope Planner</h2>
    </div>
</div>
    
<div id="firstDiv" class="flex-container-top">
    <div>
        <form action="javascript:ViewTarget()">
            Target:<br>
            <input type="text" id="target"><br>
        </form>
    </div>
    <div>
        <form>
            Service:<br>
            <select id="current-telescope-service" onchange="javascript:ViewImage(1)">
            </select>
        </form>
    </div>
    <div>
        <form>
            Telescope:<br>
            <select id="current-telescope" onchange="javascript:ViewImage(2)">
            </select>
        </form>
    </div>
    <div>
        <form>
            View:<br>
            <select id="grid_type" onchange="javascript:ViewImage(0)">
                <option value="fov">FoV</option>
                <option value="mosaic">Mosaic grid</option>
                <option value="panels">Mosaic panels</option>
            </select>
        </form>
    </div>
    <div>
        <form action="javascript:ViewImage(0)">
            Mosaic overlap (%):<br>
            <input type="number" id="overlap_percentage" min="1" max="100">
        </form>    
    </div>
    <div>
        <form action="javascript:ViewImage(0)">
            Grid size (x,y):<br>
            <input type="number" id="size_x" min="1" max="10">
            <input type="number" id="size_y" min="1" max="10">
        </form>    
    </div>
    <div>
        <form action="javascript:ViewImage(0)">
            Date (YYYY-MM-DD):<br>
            <input type="text" id="view_date">
        </form>    
    </div>
    <div>
        <br>
        <button onclick="ViewImage(0)">View image</button>
    </div>
    <div>
        <br>
        <p id="error_text"></p>
    </div>
</div>

<div id="secondDiv" class="flex-container-top2">

    <div>
        <form>
            <select id="catalog-selection" onchange="javascript:filterChanged()">
            </select>
        </form>
    </div>
    <div id ="catalogDiv">
    </div>
    <div>
        <form>
            Altitude:
            <select id="catalogFilterDegrees" onchange="javascript:filterChanged()">
                <option value="all">All</option>
                <option value="0">0°</option>
                <option value="15">15°</option>
                <option value="30">30°</option>
                <option value="45">45°</option>
                <option value="60">60°</option>
                <option value="75">75°</option>
            </select>
        </form>
    </div>
    <div>
        <form action="javascript:filterTimeChanged()">
            Time:
            <input type="text" id="catalogFilterTime" size=5>
        </form>    
    </div>
    <div>
        <form>
            Moon:
            <select id="catalogFilterMoon" onchange="javascript:filterChanged()">
                <option value="all">All</option>
                <option value="45">45°</option>
                <option value="90">90°</option>
                <option value="135">145°</option>
            </select>
        </form>
    </div>
    <div>
        <form action="javascript:ViewImage(0)">
            <input type="checkbox" id="wikiCheckbox">Wiki
        </form>    
    </div>
</div>

<div class="flex-container">
    <div id="target-image-div">
    <div id="aladin-lite-div-00" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-00"></p>
    </div>
    <div>
    <div id="aladin-lite-div-01" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-01"></p>
    </div>
    <div>
    <div id="aladin-lite-div-02" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-02"></p>
    </div>
    <div>
    <div id="aladin-lite-div-03" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-03"></p>
    </div>
    <div>
    <div id="aladin-lite-div-04" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-04"></p>
    </div>
</div>
<div class="flex-container">
    <div  id="day-visibility-div">
    <div id="aladin-lite-div-10" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-10"></p>
    </div>
    <div>
    <div id="aladin-lite-div-11" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-11"></p>
    </div>
    <div>
    <div id="aladin-lite-div-12" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-12"></p>
    </div>
    <div>
    <div id="aladin-lite-div-13" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-13"></p>
    </div>
    <div>
    <div id="aladin-lite-div-14" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-14"></p>
    </div>
</div>
<div class="flex-container">
    <div id="year-visibility-div">
    <div id="aladin-lite-div-20" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-20"></p>
    </div>
    <div>
    <div id="aladin-lite-div-21" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-21"></p>
    </div>
    <div>
    <div id="aladin-lite-div-22" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-22"></p>
    </div>
    <div>
    <div id="aladin-lite-div-23" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-23"></p>
    </div>
    <div>
    <div id="aladin-lite-div-24" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-24"></p>
    </div>
</div>
<div class="flex-container">
    <div>
    <div id="aladin-lite-div-30" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-30"></p>
    </div>
    <div>
    <div id="aladin-lite-div-31" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-31"></p>
    </div>
    <div>
    <div id="aladin-lite-div-32" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-32"></p>
    </div>
    <div>
    <div id="aladin-lite-div-33" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-33"></p>
    </div>
    <div>
    <div id="aladin-lite-div-34" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-34"></p>
    </div>
</div>
<div class="flex-container">
    <div>
    <div id="aladin-lite-div-40" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-40"></p>
    </div>
    <div>
    <div id="aladin-lite-div-41" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-41"></p>
    </div>
    <div>
    <div id="aladin-lite-div-42" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-42"></p>
    </div>
    <div>
    <div id="aladin-lite-div-43" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-43"></p>
    </div>
    <div>
    <div id="aladin-lite-div-44" style="width:300px;height:300px;"></div>
    <br>
    <p id="panel-text-44"></p>
    </div>
</div>

<div class="footer">
    <p>Author: Jarmo Ruuth. Feedback: <a href="https://forums.ruuth.xyz">forums.ruuth.xyz</a> or <a href="mailto:astroimagetools@gmail.com">astroimagetools@gmail.com</a>
        <br><a href="AstroMosaicInfo.html#credits">Credits</a></small></p>
</div>

<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
<script type="text/javascript">

var version_text = 
    "Version 1.32\n"+
    "- Started using fetch API instead of XMLHttpRequest\n" +
    "- Another fix to mosaic coordinate format for Telescope Live\n" +
    "Version 1.31\n"+
    "- Fix to mosaic coordinate format for Telescope Live\n" +
    "Version 1.30\n"+
    "- Added Telescope Live telescopes\n"+
    "- Added more catalogs to filtered view list\n"+
    "- Restructured code for telescope and catalog handling\n"+
    "Version 1.28\n"+
    "- Added astronomical seeing widget\n"+
    "Version 1.27\n"+
    "- Added Sharpless and RCW catalogs\n"+
    "Version 1.26\n"+
    "- Better error handling\n"+
    "Version 1.25\n"+
    "- Show RA/DEC in different coordinate formats in FoV view\n"+
    "Version 1.24\n"+
    "- Added color coding to separate visible and not visible Slooh 500 targets\n"+
    "Version 1.23\n"+
    "- Added C2LPT (Lunar and Planetary Telescope)\n"+
    "Version 1.22\n"+
    "- NGC and IC catalog layer added, not enabled by default\n"+
    "- Object markers are clickable and show a short info or Wiki page\n"+
    "Version 1.21\n"+
    "- Added C2 and C2FR, where FR is the scope with Focal Reducer\n"+
    "Version 1.20\n"+
    "- Added Slooh 500 target name layer, enabled by default\n"+
    "- Added map view control button\n"+
    "- Added full screen control button\n"+
    "Version 1.19\n"+
    "- Added C2 current_telescope\n"+
    "Version 1.18\n"+
    "- Added link to my other Astro Image Tools at https://ruuth.xyz/AstroImageTools.html\n"+
    "Version 1.17\n"+
    "- Multiple target coordinates can be listed in target field separated by comma\n"+
    "- Coordinate Format HHMMSS DDMMSS is also accepted\n"+
    "Version 1.16\n"+
    "- Added visible/not visible line type to year visibility\n"+
    "Version 1.15\n"+
    "- Fixed a few Slooh 500 list coordinates\n"+
    "Version 1.14\n"+
    "- Fixed ra/dec parsing with missing seconds part\n"+
    "Version 1.13\n"+
    "- moon distance filter for Slooh 500 list\n"+
    "- more Slooh 500 list filter points\n"+
    "- separate field for error text\n"+
    "Version 1.12\n"+
    "- changes to work better on mobile devices\n"+
    "Version 1.11\n"+
    "- mosaic grid max size increased to 10x10\n"+
    "- target coordinates can be given also in RA.ddd DEC.ddd format\n"+
    "- mosaic grid coordinates are shown as a table\n"+
    "Version 1.10\n"+
    "- added Slooh 500 list with altitude and time filtering\n"+
    "- added embedded Wikipedia page if Wiki checkbox is checked\n"+
    "- mosaic panel view shows actual panels up to size 5x5\n"+
    "Version 1.00\n"+
    "- basic FoV, mosaic grid and panels views\n"+
    "- target visibility during one night and next 12 months\n";

var startup_image = "Horsehead nebula";

// Messier cata log is in the source as a dedault catalog (altough
// not that useful for southern sky). But we need to have some
// catalog in place at statup and loading catalogs may take time.
var messier_catalog = { 
"Credits" : "Information retrieved from Sesame",
"format" : ["CAT", "RA", "DEC", "TYPE", "CON", "BMAG", "DST", "NAME", "INFO"],
"data" : [
["M 1",5.57554,22.0145,"SuperNova Remnant","",0,0,"",""],
["M 2",21.55751,-0.82325,"Globular Cluster","",0,0,"",""],
["M 3",13.70323,28.37728,"Globular Cluster","",0,0,"",""],
["M 4",16.39312,-26.52575,"Globular Cluster","",0,0,"",""],
["M 5",15.30923,2.08103,"Globular Cluster","",0,0,"",""],
["M 6",17.67222,-32.25333,"Open (galactic) Cluster","",0,0,"",""],
["M 7",17.8975,-34.79333,"Open (galactic) Cluster","",0,0,"",""],
["M 8",18.06028,-24.38667,"HII (ionized) region","",0,0,"",""],
["M 9",17.31994,-18.51625,"Globular Cluster","",0,0,"",""],
["M 10",16.95251,-4.10031,"Globular Cluster","",0,0,"",""],
["M 11",18.85139,-6.27,"Open (galactic) Cluster","",0,0,"",""],
["M 12",16.78727,-1.94853,"Globular Cluster","",0,0,"",""],
["M 13",16.6949,36.46132,"Globular Cluster","",0,0,"",""],
["M 14",17.62671,-3.24592,"Globular Cluster","",0,0,"",""],
["M 15",21.49954,12.167,"Globular Cluster","",0,0,"",""],
["M 16",18.31333,-13.80667,"Open (galactic) Cluster","",0,0,"",""],
["M 17",18.34639,-16.17167,"Open (galactic) Cluster","",0,0,"",""],
["M 18",18.33278,-17.10167,"Open (galactic) Cluster","",0,0,"",""],
["M 19",17.0438,-26.26794,"Globular Cluster","",0,0,"",""],
["M 20",18.045,-22.97167,"Open (galactic) Cluster","",0,0,"",""],
["M 21",18.07028,-22.49,"Open (galactic) Cluster","",0,0,"",""],
["M 22",18.60665,-23.90475,"Globular Cluster","",0,0,"",""],
["M 23",17.95111,-18.985,"Open (galactic) Cluster","",0,0,"",""],
["M 24",18.28,-18.55,"Association of Stars","",0,0,"",""],
["M 25",18.52972,-19.11667,"Open (galactic) Cluster","",0,0,"",""],
["M 26",18.755,-9.38333,"Open (galactic) Cluster","",0,0,"",""],
["M 27",19.99343,22.7212,"Planetary Nebula","",0,0,"",""],
["M 28",18.40914,-24.86983,"Globular Cluster","",0,0,"",""],
["M 29",20.39889,38.52333,"Open (galactic) Cluster","",0,0,"",""],
["M 30",21.67281,-23.17986,"Globular Cluster","",0,0,"",""],
["M 31",0.71231,41.26875,"Galaxy","",0,0,"",""],
["M 32",0.71162,40.86517,"Interacting Galaxies","",0,0,"",""],
["M 33",1.56414,30.65994,"Galaxy in Group of Galaxies","",0,0,"",""],
["M 34",2.70139,42.76167,"Open (galactic) Cluster","",0,0,"",""],
["M 35",6.14833,24.33333,"Open (galactic) Cluster","",0,0,"",""],
["M 36",5.605,34.14,"Open (galactic) Cluster","",0,0,"",""],
["M 37",5.87167,32.55333,"Open (galactic) Cluster","",0,0,"",""],
["M 38",5.47861,35.855,"Open (galactic) Cluster","",0,0,"",""],
["M 39",21.53,48.43333,"Open (galactic) Cluster","",0,0,"",""],
["M 40",12.37015,58.08294,"Composite object","",0,0,"",""],
["M 41",6.76694,-20.75667,"Open (galactic) Cluster","",0,0,"",""],
["M 42",5.58814,-5.39111,"HII (ionized) region","",0,0,"",""],
["M 43",5.59194,-5.27,"HII (ionized) region","",0,0,"",""],
["M 44",8.67333,19.66667,"Open (galactic) Cluster","",0,0,"",""],
["M 45",3.78333,24.11667,"Open (galactic) Cluster","",0,0,"",""],
["M 46",7.69611,-14.81,"Open (galactic) Cluster","",0,0,"",""],
["M 47",7.60972,-14.48333,"Open (galactic) Cluster","",0,0,"",""],
["M 48",8.22861,-5.75,"Open (galactic) Cluster","",0,0,"",""],
["M 49",12.49633,8.00041,"Seyfert 2 Galaxy","",0,0,"",""],
["M 50",7.04653,-8.33778,"Open (galactic) Cluster","",0,0,"",""],
["M 51",13.49797,47.19526,"Galaxy in Pair of Galaxies","",0,0,"",""],
["M 52",23.41333,61.59333,"Open (galactic) Cluster","",0,0,"",""],
["M 53",13.21535,18.16817,"Globular Cluster","",0,0,"",""],
["M 54",18.91759,-30.47986,"Globular Cluster","",0,0,"",""],
["M 55",19.66659,-30.96475,"Globular Cluster","",0,0,"",""],
["M 56",19.27655,30.18347,"Globular Cluster","",0,0,"",""],
["M 57",18.89308,33.02913,"Planetary Nebula","",0,0,"",""],
["M 58",12.62878,11.81809,"Seyfert Galaxy","",0,0,"",""],
["M 59",12.70064,11.64693,"Galaxy in Group of Galaxies","",0,0,"",""],
["M 60",12.72778,11.55261,"Galaxy in Pair of Galaxies","",0,0,"",""],
["M 61",12.36526,4.47377,"Seyfert 2 Galaxy","",0,0,"",""],
["M 62",17.02017,-30.11236,"Globular Cluster","",0,0,"",""],
["M 63",13.26369,42.02937,"LINER-type Active Galaxy Nucleus","",0,0,"",""],
["M 64",12.94547,21.68266,"Seyfert Galaxy","",0,0,"",""],
["M 65",11.31554,13.09221,"Galaxy in Pair of Galaxies","",0,0,"",""],
["M 66",11.33751,12.99129,"Galaxy in Pair of Galaxies","",0,0,"",""],
["M 67",8.855,11.8,"Open (galactic) Cluster","",0,0,"",""],
["M 68",12.65777,-26.74406,"Globular Cluster","",0,0,"",""],
["M 69",18.52308,-32.34808,"Globular Cluster","",0,0,"",""],
["M 70",18.72021,-32.29211,"Globular Cluster","",0,0,"",""],
["M 71",19.89625,18.77919,"Globular Cluster","",0,0,"",""],
["M 72",20.89103,-12.53731,"Globular Cluster","",0,0,"",""],
["M 73",20.98333,-12.63333,"Cluster of Stars","",0,0,"",""],
["M 74",1.6116,15.78346,"Galaxy","",0,0,"",""],
["M 75",20.10134,-21.92226,"Globular Cluster","",0,0,"",""],
["M 76",1.70546,51.57543,"Planetary Nebula","",0,0,"",""],
["M 77",2.71133,-0.01329,"Galaxy in Pair of Galaxies","",0,0,"",""],
["M 78",5.77939,0.07917,"Reflection Nebula","",0,0,"",""],
["M 79",5.40294,-24.52425,"Globular Cluster","",0,0,"",""],
["M 80",16.284,-22.97608,"Globular Cluster","",0,0,"",""],
["M 81",9.92588,69.06529,"Seyfert 2 Galaxy","",0,0,"",""],
["M 82",9.93123,69.6797,"Interacting Galaxies","",0,0,"",""],
["M 83",13.61692,-29.86576,"Starburst Galaxy","",0,0,"",""],
["M 84",12.41771,12.88698,"Seyfert 2 Galaxy","",0,0,"",""],
["M 85",12.42335,18.19108,"Galaxy in Pair of Galaxies","",0,0,"",""],
["M 86",12.43661,12.94597,"Galaxy in Group of Galaxies","",0,0,"",""],
["M 87",12.51373,12.39112,"Brightest galaxy in a Cluster (BCG)","",0,0,"",""],
["M 88",12.53312,14.42041,"Seyfert 2 Galaxy","",0,0,"",""],
["M 89",12.59439,12.55634,"LINER-type Active Galaxy Nucleus","",0,0,"",""],
["M 90",12.61384,13.16287,"Seyfert 2 Galaxy","",0,0,"",""],
["M 91",12.59068,14.49632,"LINER-type Active Galaxy Nucleus","",0,0,"",""],
["M 92",17.28539,43.13594,"Globular Cluster","",0,0,"",""],
["M 93",7.74167,-23.85667,"Open (galactic) Cluster","",0,0,"",""],
["M 94",12.8481,41.12015,"Seyfert Galaxy","",0,0,"",""],
["M 95",10.7327,11.70361,"Galaxy in Pair of Galaxies","",0,0,"",""],
["M 96",10.77937,11.81994,"Galaxy in Pair of Galaxies","",0,0,"",""],
["M 97",11.24659,55.01902,"Planetary Nebula","",0,0,"",""],
["M 98",12.23008,14.90047,"LINER-type Active Galaxy Nucleus","",0,0,"",""],
["M 99",12.31378,14.41649,"HII Galaxy","",0,0,"",""],
["M 100",12.38193,15.8223,"Active Galaxy Nucleus","",0,0,"",""],
["M 101",14.0535,54.34875,"Galaxy in Pair of Galaxies","",0,0,"",""],
["M 102",15.10821,55.76331,"Seyfert Galaxy","",0,0,"",""],
["M 103",1.55639,60.65,"Open (galactic) Cluster","",0,0,"",""],
["M 104",12.66651,-11.62305,"LINER-type Active Galaxy Nucleus","",0,0,"",""],
["M 105",10.79711,12.58163,"LINER-type Active Galaxy Nucleus","",0,0,"",""],
["M 106",12.31601,47.30372,"Seyfert 2 Galaxy","",0,0,"",""],
["M 107",16.54218,-13.05378,"Globular Cluster","",0,0,"",""],
["M 108",11.19194,55.67412,"Starburst Galaxy","",0,0,"",""],
["M 109",11.96,53.37452,"Galaxy in Group of Galaxies","",0,0,"",""],
["M 110",0.67279,41.68542,"Galaxy in Group of Galaxies","",0,0,"",""]
]
};

var chile1Hard = [
7.75,5.75,3.5,1.75,1.75,1.75,6.75,1.5,1,0.75,0.5,0.5,0.25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.5,0.75,1.25,0.75,0.5,0.5,4,13.5,11,
8.5,6,2.25,0,0.25,1.25,4,5.25,6.5,7.5,8.25,9.25,10,10.25,10.5,10.75,11,11.25,11.25,11,11.75,12.25,13,13.5,32.5,16.75,11.5,12,
12.75,13.25,13,12.75,11.75,10.75
];
var chileSoft = [
18,18,18,18,18,18,18,18,18,20,22,24,25,30,35,42,47,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,
50,50,50,47,40,35,30,25,24,22,20,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18
];
var teide1Hard = [
27,25,24,23,21.5,20,18,16,13.5,11,10,9,9,9,9,9,9,9,9,9,10,11,11.5,12,13.5,15,17,19,22,25,26.5,28,29.5,31,32,33,32,31,29.5,
28,26.5,25,22,19,18,15,14,13,13,13,13.5,14,14,14,12,12,12.5,13,12.5,12,12,12,15,16,18.5,21,22,23,23.5,24,26
];
var teide2Hard = [
30,26.6,24.8,23.8,22.7,21.2,19.6,17.6,15.5,13,10.8,9.8,9,9,9,9,9,9,9,9,9.2,10.2,11.1,11.6,12.3,13.8,15.4,17.4,19.6,33,33,33,
33,33,33,33,33,33,33,33,33,26.2,24.4,21.4,18.8,17.4,14.8,13.8,13,13,13.1,13.6,14,14,13.6,12,12.1,12.6,12.9,12.4,12,12,12.6,
15.2,16.5,19,21.2,22.2,23.1,23.6,24.4
];
var teide3Hard = [
10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10
];
var teide4Hard = [
10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10
];
var teideSoft = [
30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,33,33,33,33,33,33,33,33,33,33,33,33,33,30,
30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30
];

var horizon0 = [
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
];

var horizon20 = [
20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20
];

var horizon30 = [
30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,
30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30
];

// Seeing widget from https://www.meteoblue.com/
var weather_services = [
    { name: "slooh-teide", url: '<iframe src="https://www.meteoblue.com/en/weather/widget/seeing/parque-nacional-del-teide_spain_2510570?geoloc=fixed&noground=0"  frameborder="0" scrolling="NO" allowtransparency="true" sandbox="allow-same-origin allow-scripts allow-popups allow-popups-to-escape-sandbox" style="width: 520px; height: 695px"></iframe><div><!-- DO NOT REMOVE THIS LINK --><a href="https://www.meteoblue.com/en/weather/forecast/seeing/parque-nacional-del-teide_spain_2510570?utm_source=weather_widget&utm_medium=linkus&utm_content=seeing&utm_campaign=Weather%2BWidget" target="_blank">meteoblue</a></div>' },
    { name: "slooh-chile", url: '<iframe src="https://www.meteoblue.com/en/weather/widget/seeing/la-dehesa_chile_3886112?geoloc=fixed&noground=0"  frameborder="0" scrolling="NO" allowtransparency="true" sandbox="allow-same-origin allow-scripts allow-popups allow-popups-to-escape-sandbox" style="width: 520px; height: 711px"></iframe><div><!-- DO NOT REMOVE THIS LINK --><a href="https://www.meteoblue.com/en/weather/forecast/seeing/la-dehesa_chile_3886112?utm_source=weather_widget&utm_medium=linkus&utm_content=seeing&utm_campaign=Weather%2BWidget" target="_blank">meteoblue</a></div>'},
    { name: "tl-chi", url: '<iframe src="https://www.meteoblue.com/en/weather/widget/seeing/portezuelo-del-chaco_chile_3895723?geoloc=fixed&noground=0"  frameborder="0" scrolling="NO" allowtransparency="true" sandbox="allow-same-origin allow-scripts allow-popups allow-popups-to-escape-sandbox" style="width: 520px; height: 711px"></iframe><div><!-- DO NOT REMOVE THIS LINK --><a href="https://www.meteoblue.com/en/weather/forecast/seeing/portezuelo-del-chaco_chile_3895723?utm_source=weather_widget&utm_medium=linkus&utm_content=seeing&utm_campaign=Weather%2BWidget" target="_blank">meteoblue</a></div>'},
    { name: "tl-spa", url: '<iframe src="https://www.meteoblue.com/en/weather/widget/seeing/el-chaparral-alto_spain_2518568?geoloc=fixed&noground=0"  frameborder="0" scrolling="NO" allowtransparency="true" sandbox="allow-same-origin allow-scripts allow-popups allow-popups-to-escape-sandbox" style="width: 520px; height: 695px"></iframe><div><!-- DO NOT REMOVE THIS LINK --><a href="https://www.meteoblue.com/en/weather/forecast/seeing/el-chaparral-alto_spain_2518568?utm_source=weather_widget&utm_medium=linkus&utm_content=seeing&utm_campaign=Weather%2BWidget" target="_blank">meteoblue</a></div>'},
    { name: "tl-aus", url: '<iframe src="https://www.meteoblue.com/en/weather/widget/seeing/mount-manton_australia_8167256?geoloc=fixed&noground=0"  frameborder="0" scrolling="NO" allowtransparency="true" sandbox="allow-same-origin allow-scripts allow-popups allow-popups-to-escape-sandbox" style="width: 520px; height: 695px"></iframe><div><!-- DO NOT REMOVE THIS LINK --><a href="https://www.meteoblue.com/en/weather/forecast/seeing/mount-manton_australia_8167256?utm_source=weather_widget&utm_medium=linkus&utm_content=seeing&utm_campaign=Weather%2BWidget" target="_blank">meteoblue</a></div>'},
    { name: "detect_location", url: '<iframe src="https://www.meteoblue.com/en/weather/widget/seeing?geoloc=detect&noground=0"  frameborder="0" scrolling="NO" allowtransparency="true" sandbox="allow-same-origin allow-scripts allow-popups allow-popups-to-escape-sandbox" style="width: 520px; height: 711px"></iframe><div><!-- DO NOT REMOVE THIS LINK --><a href="https://www.meteoblue.com/en/weather/forecast/seeing?utm_source=weather_widget&utm_medium=linkus&utm_content=seeing&utm_campaign=Weather%2BWidget" target="_blank">meteoblue</a></div>'}
];

var slooh_telescopes = [
    { name: "T1", fov_x: 37, fov_y: 37, lat: 28.29970, lng: -16.50826, alt: 2372, weather: "slooh-teide", weather_url: null, horizonHard: teide1Hard, horizonSoft: teideSoft }, 
    { name: "T2", fov_x: 43, fov_y: 43, lat: 28.29970, lng: -16.50826, alt: 2372, weather: "slooh-teide", weather_url: null, horizonHard: teide2Hard, horizonSoft: teideSoft }, 
    { name: "T2UWF", fov_x: 107.6, fov_y: 72.12, lat: 28.29970, lng: -16.50826, alt: 2372, weather: "slooh-teide", weather_url: null, horizonHard: teide2Hard, horizonSoft: teideSoft }, 
    { name: "T3", fov_x: 99.14, fov_y: 74.56, lat: 28.29970, lng: -16.50826, alt: 2372, weather: "slooh-teide", weather_url: null, horizonHard: teide3Hard, horizonSoft: teideSoft }, 
    { name: "T4", fov_x: 15.57, fov_y: 12.03, lat: 28.29970, lng: -16.50826, alt: 2372, weather: "slooh-teide", weather_url: null, horizonHard: teide4Hard, horizonSoft: teideSoft }, 

    { name: "C1", fov_x: 31.18, fov_y: 20.51, lat: -33.269, lng: -70.534, alt: 1450, weather: "slooh-chile", weather_url: null, horizonHard: teide1Hard, horizonSoft: teideSoft }, 
    { name: "C1UWF", fov_x: 81.49, fov_y: 82, lat: -33.269, lng: -70.534, alt: 1450, weather: "slooh-chile", weather_url: null, horizonHard: teide1Hard, horizonSoft: teideSoft }, 
    { name: "C2", fov_x: 43, fov_y: 43, lat: -33.269, lng: -70.534, alt: 1450, weather: "slooh-chile", weather_url: null, horizonHard: teide1Hard, horizonSoft: teideSoft }, 
    { name: "C2FR", fov_x: 65, fov_y: 65, lat: -33.269, lng: -70.534, alt: 1450, weather: "slooh-chile", weather_url: null, horizonHard: teide1Hard, horizonSoft: teideSoft }, 
    { name: "C2LPT", fov_x: 8.24, fov_y: 5.18, lat: -33.269, lng: -70.534, alt: 1450, weather: "slooh-chile", weather_url: null, horizonHard: teide1Hard, horizonSoft: teideSoft }
];

var telescope_live_telescopes = [
    { name: "SPA-1", fov_x: 324, fov_y: 324, lat: 37.50103, lng: -2.40857, alt: 1025, weather: "tl-spa", weather_url: null, horizonHard: horizon30, horizonSoft: horizon30 }, 
    { name: "SPA-2", fov_x: 23, fov_y: 23, lat: 37.50103, lng: -2.40857, alt: 1025, weather: "tl-spa", weather_url: null, horizonHard: horizon30, horizonSoft: horizon30 }, 
    { name: "SPA-3", fov_x: 324, fov_y: 324, lat: 37.50103, lng: -2.40857, alt: 1025, weather: "tl-spa", weather_url: null, horizonHard: horizon30, horizonSoft: horizon30 }, 
    
    { name: "CHI-1", fov_x: 32, fov_y: 32, lat: -30.47253, lng: -70.76300, alt: 1025, weather: "tl-chi", weather_url: null, horizonHard: horizon30, horizonSoft: horizon30 }, 
    { name: "CHI-2", fov_x: 67, fov_y: 67, lat: -30.47253, lng: -70.76300, alt: 1025, weather: "tl-chi", weather_url: null, horizonHard: horizon30, horizonSoft: horizon30 }, 
    { name: "CHI-3", fov_x: 19, fov_y: 19, lat: -30.47253, lng: -70.76300, alt: 1025, weather: "tl-chi", weather_url: null, horizonHard: horizon30, horizonSoft: horizon30 }, 
    { name: "CHI-4", fov_x: 67, fov_y: 67, lat: -30.47253, lng: -70.76300, alt: 1025, weather: "tl-chi", weather_url: null, horizonHard: horizon30, horizonSoft: horizon30 }, 
    { name: "CHI-5", fov_x: 473, fov_y: 378, lat: -30.47253, lng: -70.76300, alt: 1025, weather: "tl-chi", weather_url: null, horizonHard: horizon30, horizonSoft: horizon30 },

    { name: "AUS-2", fov_x: 324, fov_y: 324, lat: -34.86416, lng: 148.97639, alt: 648, weather: "tl-aus", weather_url: null, horizonHard: horizon20, horizonSoft: horizon20 }   
];

var catalogs = [
    { name: "Messier", targets: messier_catalog.data, url: "https://ruuth.xyz/Messier.json" , source: "simbad", AladinCatalog: null, color: '#29a329' },
    { name: "Slooh 500 Teide", targets: null, url: "https://ruuth.xyz/Slooh500Teide.json" , source: "slooh", AladinCatalog: null, color: '#29a329' },
    { name: "Slooh 500 Chile", targets: null, url: "https://ruuth.xyz/Slooh500Chile.json" , source: "slooh", AladinCatalog: null, color: '#29a329' },
    { name: "NGC", targets: null, url: "https://ruuth.xyz/OpenNGC.json",  source: "openngc", AladinCatalog: null, color: '#cccccc' },
    { name: "IC", targets: null, url: "https://ruuth.xyz/OpenIC.json",  source: "openngc", AladinCatalog: null, color: '#cccccc' },
    { name: "RCW", targets: null, url: "https://ruuth.xyz/RCW.json", source: "simbad", AladinCatalog: null, color: '00af00' },
    { name: "Sharpless", targets: null, url: "https://ruuth.xyz/Sharpless.json", source: "simbad", AladinCatalog: null, color: '#00afff' }
];

var telescope_services = [
    { name: "Slooh", radec_format: 0, telescopes: slooh_telescopes },
    { name: "Telescope Live", radec_format: 1, telescopes: telescope_live_telescopes }
];

// screen location for some items
var image_panel = "aladin-lite-div-00";
var image_panel_text = "panel-text-00";
var wiki_panel = "aladin-lite-div-01";
var dayvisibility_panel = "aladin-lite-div-10";
var dayvisibility_panel_text = "panel-text-10";
var yearvisibility_panel = "aladin-lite-div-20";
var yearvisibility_panel_text = "panel-text-20";
var weather_panel = "aladin-lite-div-30";
var wiki_panel_width = "500px";
var wiki_frame_width = 500;
var status_text = "error_text";
var error_text = "error_text";
var alt_wikitext = null;

if (screen.height > screen.width) {
    // screen is taller than it is wide
    wiki_panel = "aladin-lite-div-30";
    wiki_panel_width = "700px";
    wiki_frame_width = 700;
    version_text = null;
    var weather_panel = "aladin-lite-div-40";
}

// size means number of panels on each side
// 0.5 means 2 panels
// 1 means 3 panels
// 1.5 means 4 panes etc.
var size_x = 1;
var size_y = 1;

var current_telescope_service = telescope_services[0];
var current_telescope = current_telescope_service.telescopes[0];
var current_telescope_service_selected_index = 0;   // for init
var current_telescope_selected_index = 0;           // for init
var fov_x;
var fov_y;
var img_fov = 0.8;  // field of view for single image considering the overlap
var img_size = 300;
var image_target;
var image_target_list = [];

var UTCdate_ms;

var url = new URL(window.location);
console.log(url);

var resolved_name = null;
var resolved_coordinates = null;

var target_ra;
var target_dec;
var location_lat;
var location_lng;

var hour_ms = 60*60*1000;
var day_ms = 24*hour_ms;
var degToRad = Math.PI/180.0;
var radToDeg = 180.0/Math.PI;
var degToHours = 1/15;
var hoursToDeg = 15;
var JD1970 = 2440587.5;     // JD 1970-01-01 00:00 - Javascript zero time

var current_catalog = null;                 // current visible catalog
var current_catalog_filtered_list = null;   // filtered list of catalog items
var catalog_filters_changed = true;
var catalogDiv_select = null;
var catalog_text = null;
var catalog_date = null;
var catalog_filter_time = null;
var catalogFilterDegrees = null;
var catalogFilterMoon = null;
var catalog_index = null;

var wikiChecked = false;

// Hard and soft limits for current telecope
var horizonHard = [];
var horizonSoft = [];

var url_target = null;
var url_new_service = null;
var url_service = null;
var url_telescope = null;
var url_name = null;
var url_grid_type = null;
var url_overlap = null;
var url_date = null;

if (typeof URLSearchParams === "function") {
    searchParams = new URLSearchParams(url.search.slice(1));
    url_target = searchParams.get('target');
    url_new_service = searchParams.get('new_service');
    url_service = searchParams.get('service');
    url_telescope = searchParams.get('telescope');
    url_name = searchParams.get('name');
    url_grid_type = searchParams.get('grid_type');
    url_overlap = searchParams.get('overlap');
    url_date = searchParams.get('date');
}

if (url_target) {
    console.log("url_target", url_target);
    startup_image = url_target;
}
if (url_new_service) {
    console.log("url_new_service", url_new_service);
    var url_service_list = url_new_service.split(';');
    for (var n = 0; n < url_service_list.length; n++) {
        var params = url_service_list[n].split(',');
        if (params.length < 6) {
            alert("Too few parameters in url-parameter new_service! Ignoring new_service " + params[0] + ".");
        } else {
            var new_telescope = {
                name: params[1], fov_x: parseFloat(params[2]), fov_y: parseFloat(params[3]), lat: parseFloat(params[4]), lng: parseFloat(params[5]),
                alt: 0, weather: null, weather_url: null, horizonHard: horizon0, horizonSoft: horizon0
            };
            if (params.length >= 7) {
                for (var i = 0; i < weather_services.length; i++) {
                    if (weather_services[i].name == params[6]) {
                        new_telescope.weather = params[6];
                        break;
                    }
                }
            }
            for (var i = 0; i < telescope_services.length; i++) {
                if (telescope_services[i].name == params[0]) {
                    // add new telescopy to existing service
                    telescope_services[i].telescopes[telescope_services[i].telescopes.length] = new_telescope;
                    if (n == 0) {
                        current_telescope_service = telescope_services[i];
                        current_telescope_service_selected_index = i;
                        current_telescope = current_telescope_service.telescopes[current_telescope_service.telescopes.length - 1];
                        current_telescope_service_selected_index = telescope_services.length - 1;
                    }
                    break;
                }
            }
            if (i == telescope_services.length) {
                // add a new telescope service
                var new_service = { name: params[0], radec_format: 1, telescopes: [ new_telescope ] };
                telescope_services[telescope_services.length] = new_service;
                if (n == 0) {
                    current_telescope_service = new_service;
                    current_telescope = current_telescope_service.telescopes[0];
                    current_telescope_service_selected_index = telescope_services.length - 1;
                }
            }
        }
    }
}
if (url_service) {
    console.log("url_service", url_service);
    for (var i = 0; i < telescope_services.length; i++) {
        if (telescope_services[i].name == url_service) {
            current_telescope_service = telescope_services[i];
            current_telescope = current_telescope_service.telescopes[0];
            current_telescope_service_selected_index = i;
            break;
        }
    }
}
if (url_telescope) {
    console.log("url_telescope", url_telescope);
    for (var i = 0; i < current_telescope_service.telescopes.length; i++) {
        if (current_telescope_service.telescopes[i].name == url_telescope) {
            current_telescope = current_telescope_service.telescopes[i];
            current_telescope_selected_index = i;
            break;
        }
    }
}
if (url_name) {
    document.getElementById("astro_mosaic_title").innerHTML = url_name;
}
if (url_grid_type) {
    document.getElementById("grid_type").value = url_grid_type;
}
if (url_overlap) {
    document.getElementById("overlap_percentage").value = url_overlap;
} else {
    document.getElementById("overlap_percentage").value = 20;
}
if (url_date) {
    document.getElementById("view_date").value = url_date;
} else {
    var d = new Date();
    document.getElementById("view_date").value = d.toISOString().substr(0, 10);
}

// initialization
initAstroMosaic();

if (startup_image) {
    document.getElementById("target").value = startup_image;
    ViewImage(0);
}

document.getElementById("size_x").value = 3;
document.getElementById("size_y").value = 3;

function initAstroMosaic()
{
    load_and_init_catalogs();
    update_telescope_service_list();
    update_telescope_list(current_telescope_service.name);
    update_catalog_list();
    init_catalog_view_list();

    // Update telescope FoV values.
    for (var i = 0; i < telescope_services.length; i++) {
        for (var j = 0; j < telescope_services[i].telescopes.length; j++) {
            telescope_services[i].telescopes[j].fov_x = getFov(telescope_services[i].telescopes[j].fov_x);
            telescope_services[i].telescopes[j].fov_y = getFov(telescope_services[i].telescopes[j].fov_y);
        }
    }
}

// convert image_target HH:MM:SS DEG:HH:MM to decimal dgrees
function get_ra_dec(target)
{
    var radec = [];

    // assume format HH:MM:SS DEG:HH:MM
    var radec = target.split(' ');
    
    var raparts = radec[0].split(':');
    var decparts = radec[1].split(':');

    radec[0] = Math.abs(parseFloat(raparts[0])) + (parseFloat(raparts[1]) * 60 + parseFloat(raparts[2])) / 3600;
    if (isNaN(radec[0])) {
        // assume seconds are missing
        radec[0] = Math.abs(parseFloat(raparts[0])) + (parseFloat(raparts[1]) * 60) / 3600;
    }
    if (isNaN(radec[0])) {
        return [];
    }
    // convert from hours to degrees
    radec[0] = radec[0] * hoursToDeg;
    if (parseFloat(raparts[0]) < 0) {
        radec[0] = -radec[0];
    }
    radec[1] = Math.abs(parseFloat(decparts[0])) + (parseFloat(decparts[1]) * 60 + parseFloat(decparts[2])) / 3600;
    if (isNaN(radec[1])) {
        // assume seconds are missing
        radec[1] = Math.abs(parseFloat(decparts[0])) + (parseFloat(decparts[1]) * 60) / 3600;
    }
    if (isNaN(radec[1])) {
        return [];
    }
    if (parseFloat(decparts[0]) < 0) {
        radec[1] = -radec[1];
    }
    return radec;
}

// convert image_target HH:MM:SS DEG:HH:MM to decimal dgrees into target_ra and target_dec
function get_image_target_ra_dec()
{
    var radec = get_ra_dec(image_target);
    if (radec.length != 2) {
        return false;
    }
    target_ra = radec[0];
    target_dec = radec[1];

    return true;
}

// scale degrees to 0-360
function scale_to_360(v)
{
    while (v < 0) {
        v = v + 360;
    }
    return v - Math.floor(v/360)*360;
}

// sin from decimal degrees
function sind(deg)
{
    return Math.sin(deg*degToRad);
}

// cos from decimal regrees
function cosd(deg)
{
    return Math.cos(deg*degToRad);
}

// Julian Days from 2000, including fraction, used by sun and moon calculations
function getJD(d)
{
    var days = JD1970 + d / day_ms - 2451543.5;
    return days;
}

// Days from J2000, including fraction, used by altitude calculations
function getJ2000_2(d)
{
    var days = JD1970 + d / day_ms - 2451545.0;
    return days;
}

// Calculate object altitude. 
// Useful links:
//      https://astronomy.stackexchange.com/questions/24859/local-sidereal-time
//      https://observability.date/notes
//      http://njsas.org/projects/tidal_forces/altaz/pausch/riset.html
//      http://www.stjarnhimlen.se/comp/tutorial.html
//      http://www.stargazing.net/kepler/altaz.html
function object_altaz(date, ra, dec, lat, lng)
{
    // universal time in decimal hours
    var H = (date % day_ms) / hour_ms;

    // Julian date including fraction - 2451545.0,
    // that is days from J2000
    var D = getJ2000_2(date);

    // calculate local sidereal time in degrees
    var LST = 100.4606184 + 0.9856473662862 * D + H * hoursToDeg + lng;

    // get hours
    LST = LST % 360;

    // calculate local hour angle in degrees
    var LHA = LST - ra;

    // calculate sin(altitude) in radian
    var sin_altitude = sind(lat) * sind(dec) + cosd(lat) * cosd(dec) * cosd(LHA);

    var altitude = Math.asin(sin_altitude) * radToDeg;

    // calculate AZ
    var cos_A = (sind(dec) - sind(altitude)*sind(lat)) / (cosd(altitude)*cosd(lat));

    var A = Math.acos(cos_A) * radToDeg;

    var AZ;
    if (sind(LHA) < 0) {
        AZ = A;
    } else {
        AZ = 360 - A;
    }

    //console.log("object_altaz, last=",LST*degToHours,",lha=",LHA*degToHours,",sinalt=",sin_altitude,",alt=",altitude,",H=",H);

    return {alt:altitude, az:AZ};
}

// Do calculations that are not based on RA/DEC
function object_altitude_init(date, lat, lng)
{
    // universal time in decimal hours
    var H = (date % day_ms) / hour_ms;

    // Julian date including fraction - 2451545.0,
    // that is days from J2000
    var D = getJ2000_2(date);

    // calculate local sidereal time in degrees
    var LST = 100.4606184 + 0.9856473662862 * D + H * hoursToDeg + lng;

    // get hours
    LST = LST % 360;


    var aa =  {Lst: LST, Sinlat: sind(lat), Coslat: cosd(lat)}

    console.log("object_altitude_init, aa", aa);

    return aa;
}

// Calculate altidude on given RA/DEC
function object_altitude_get(aa, ra, dec)
{
    // calculate local hour angle in degrees
    var LHA = aa.Lst - ra;

    // calculate sin(altitude) in radian
    var sin_altitude = aa.Sinlat * sind(dec) + aa.Coslat * cosd(dec) * cosd(LHA);

    var altitude = Math.asin(sin_altitude) * radToDeg;

    return altitude;
}

// Simplified version of moon position at given time.
// - there are a lot of variables that affect correct moon position that
//    are ignored here
// - we do not correct for altitude
// Links:
//      http://www.stjarnhimlen.se/comp/tutorial.html
function moon_position(date)
{
    // Days from J2000
    var d = getJD(date);
    var pi = Math.PI;
    var nloop;
    //console.log("moon position d=",d,"JD=",JD1970+d/day_ms);

    var N = scale_to_360(125.1228 - 0.0529538083 * d);
    var i = 5.1454;
    var w = scale_to_360(318.0634 + 0.1643573223 * d);
    var a = 60.2666;
    var e = 0.054900;
    var M = scale_to_360(115.3654 + 13.0649929509 * d);
    //console.log("N",N,"i",i,"w",w,"a",a,"e",e,"M",M);

    var E = M + e*(180/pi) * sind(M) * ( 1.0 + e * cosd(M) );
    for (nloop = 0; nloop < 100; nloop++) {
        var E0 = E;
        E = E0 - (E0 - e * (180/pi) * sind(E0) - M) / (1- e * cosd(E0));
        if (Math.abs(E-E0) <= 0.001) {
            break;
        }
    }
    //console.log("E", E, "nloop", nloop);

    var x = a * ( cosd(E) - e );
    var y = a * Math.sqrt(1.0 - e*e) * sind(E);
    //console.log("x,y",x,y);

    var r = Math.sqrt( x*x + y*y );
    var v = scale_to_360(Math.atan2( y, x ) * radToDeg);
    //console.log("r,v",r,v);

    // moon geocentric position in ecliptic coordinates
    var xeclip = r * ( cosd(N) * cosd(v+w) - sind(N) * sind(v+w) * cosd(i) );
    var yeclip = r * ( sind(N) * cosd(v+w) + cosd(N) * sind(v+w) * cosd(i) );
    var zeclip = r * ( sind(v+w) * sind(i) );
    //console.log("moon xeclip=",xeclip,",yeclip=",yeclip,",zeclip=",zeclip);

    // ecliptic longitude and latitude
    //var lonecl = scale_to_360(Math.atan2( yeclip, xeclip ) * radToDeg);
    //var latecl = Math.atan2( zeclip, Math.sqrt(xeclip*xeclip+yeclip*yeclip) ) * radToDeg;
    //console.log("lonecl,latecl",lonecl,latecl);

    var oblecl = 23.4;

    // rotate ecliptic coordinates to equatorial coordinates
    var xequat = xeclip;
    var yequat = yeclip * cosd(oblecl) - zeclip * sind(oblecl);
    var zequat = yeclip * sind(oblecl) + zeclip * cosd(oblecl);
    //console.log("moon xequat=",xequat,",yequat=",yequat,",zequat=",zequat);

    // calculate RA and Dec
    var RA  = scale_to_360(Math.atan2( yequat, xequat ) * radToDeg);
    var Dec = Math.atan2( zequat, Math.sqrt(xequat*xequat+yequat*yequat) ) * radToDeg;

    //console.log("moon ra",RA,",dec",Dec);

    return {ra:RA, dec:Dec};
}

// a simple version for topocentric correction
function moon_topocentric_correction(alt)
{
    var r = 60.336;
    return alt - Math.asin(1/r) * cosd(alt);
}

// Sun position at given time.
// Links:
//      http://www.stjarnhimlen.se/comp/tutorial.html
function sun_position(date)
{
    // Days from J2000
    var d = getJD(date);
    var pi = Math.PI;
    //console.log("sun_position d", d);

    var w = scale_to_360(282.9404 + 4.70935E-5 * d);
    var a = 1.0;
    var e = 0.016709 - 1.151E-9 * d;
    var M = scale_to_360(356.0470 + 0.9856002585 * d);

    //console.log(w,a,e,M);

    var oblecl = scale_to_360(23.4393 - 3.563E-7 * d);
    var L = scale_to_360(w + M);
    //console.log("L", L,"oblecl", oblecl);

    var E = scale_to_360((M + (180/pi) * e * sind(M) * (1 + e * cosd(M))));
    //console.log("E", E);

    var x = cosd(E) - e;
    var y = sind(E) * Math.sqrt(1 - e*e);
    //console.log("x,y", x,y);

    var r = Math.sqrt(x*x + y*y);
    var v = Math.atan2( y, x ) * radToDeg;
    //console.log("r,v", r,v);

    var lon = scale_to_360(v + w);
    //console.log("lon", lon);

    x = r * cosd(lon);
    y = r * sind(lon);
    //console.log("x,y", x,y);

    var xequat = x;
    var yequat = y * cosd(oblecl);
    var zequat = y * sind(oblecl);
    //console.log("xequat,yequat", xequat,yequat);

    var RA  = Math.atan2( yequat, xequat ) * radToDeg;
    var Dec = Math.atan2( zequat, Math.sqrt(xequat*xequat+yequat*yequat) ) * radToDeg;

    //console.log("Sun_position", RA, Dec);

    return {ra:RA, dec:Dec};
}

// Simplified version of rise and set times.
// - we do not correct for altitude
// - we use current day rise time as next day rise time
// Links:
//      http://www.stjarnhimlen.se/comp/tutorial.html
function sun_rise_set(midday, lat, lon, h)
{
    var d = getJD(midday);
    
    var sun_pos = sun_position(midday);
    var LST = sun_pos.ra;

    var w = scale_to_360(282.9404 + 4.70935E-5 * d);
    var M = scale_to_360(356.0470 + 0.9856002585 * d);
    var L = M + w;
    var GMST0 = scale_to_360(L + 180);

    var UT_sun = (LST - GMST0 - lon) * degToHours;
    if (UT_sun < 0) {
        UT_sun = UT_sun + 24;
    }
    //console.log("Sun_rise_set UT_sun", UT_sun);

    // calculate midday at location
    midday = midday - 12 * hour_ms + UT_sun * hour_ms;

    var cos_LHA = (sind(h) - sind(lat)*sind(sun_pos.dec)) / (cosd(lat) * cosd(sun_pos.dec));

    var LHA = (Math.acos(cos_LHA) * radToDeg) * degToHours;
    //console.log("Sun_rise_set LHA", LHA);

    //console.log("Sun_rise_set set rise", 12+LHA, 12-LHA);

    // we use the current day sunrise as the next sunrise which is not exactly correct
    return {sunset: midday + LHA*hour_ms, sunrise: midday - LHA*hour_ms + day_ms};
}

// Calculate distance in degrees between two (ra,dec) positions
function moon_distance(ra1, dec1, ra2, dec2)
{
    var cos_A = sind(dec1) * sind(dec2) + cosd(dec1) * cosd(dec2) * cosd(ra1 - ra2);
    var A = Math.acos(cos_A) * radToDeg;
    if (A < 0) {
        A = -A;
    }
    if (A > 180) {
        A = 360 - A;
    }
    return A;
}

// This method can be found in many places, somwhow
// it gives weird results
function get_moon_phase2(date)
{
    var d = getJD(date);

    var v = (d-2451550.1) / 29.530588853;
    v = v - Math.floor(v);
    if (v < 0) {
        v = v + 1;
    }

    var age = v * 29.53;
    return age;
}

// My own version, calcuate sun-moon angle to get
// approximate "phase" in percentages
function get_moon_phase(d)
{
    var sunpos = sun_position(d);
    var moonpos = moon_position(d);
    var dist = moon_distance(sunpos.ra, sunpos.dec, moonpos.ra, moonpos.dec);
    //console.log("get_moon_phase dist", dist);
    return (scale_to_360(dist) / 180) * 100;
}

// Convert to dtate string to that e.g. 1:0 becomes 01:00
function toDateString(num)
{
    if (num < 10) {
        return '0' + num.toString();
    } else {
        return num.toString();
    }
}

function setGridBackgroundStyle(panel)
{
    document.getElementById(panel).style.background = "white";
    document.getElementById(panel).style.padding = "10px";
    document.getElementById(panel).style.margin = "10px";
}

function setHiddenBackgroundStyle(panel)
{
    document.getElementById(panel).style.background = "white";
    document.getElementById(panel).style.padding = "0px";
    document.getElementById(panel).style.margin = "0px";
}

function setPanelBackgroundStyle(panel)
{
    document.getElementById(panel).style.background = "white";
    document.getElementById(panel).style.padding = "2px";
    document.getElementById(panel).style.margin = "2px";
}

function drawDayVisibilityandGrid() 
{
    console.log("drawDayVisibilityandGrid, image_target_list.length", image_target_list.length);

    if (image_target_list.length > 1) {
        ViewGridFromList(image_target_list);
    } else {
        ViewGrid();
    }

    var data = new google.visualization.DataTable();
    // get midday in UTC time in ms
    var midday = UTCdate_ms + day_ms/2;
    var UTCmidday = new Date(midday);

    //data.addColumn('datetime', 'Time'); Can't get this working...
    data.addColumn('string', 'Time');
    //data.addColumn('datetime', 'Time');
    data.addColumn('number', 'Visible');            // object altitude
    data.addColumn('number', 'Below soft horizon'); // object altitude if below soft horizon
    data.addColumn('number', 'Not visible');        // object altitude below hard horizon or meridian transit
    data.addColumn('number', 'Moon alt');           // moon altitude

    var interval = 5*60*1000; // 5 minutes
    
    var ra = target_ra;
    var dec = target_dec;
    
    var lat = location_lat;
    var lng = location_lng;

    console.log(ra, dec, lat, lng);

    var rowdata = [];

    var draw_full_day = 0;  // if 0 draw only during astronomical twilight

    // sun rise and set times that close match Slloh dome open times
    var suntimes = sun_rise_set(midday, lat, lng, -12);

    var UTCsunset = new Date(suntimes.sunset);
    var UTCsunrise = new Date(suntimes.sunrise);

    var starttime;
    var endtime;
    if (draw_full_day) {
        starttime = midday;
        endtime = starttime + day_ms;
    } else {
        starttime = suntimes.sunset - suntimes.sunset % interval;
        endtime = suntimes.sunrise + interval - suntimes.sunrise % interval;
    }
    var prevaz = null;
    var meridian_index = null;

    for (var d = starttime; d <= endtime; d = d + interval) {
        //console.log("d",d,"sunrise",suntimes.sunrise,"unset",suntimes.sunset);
        var altaz = object_altaz(d, ra, dec, lat, lng);
        //console.log("target az=",altaz.az,",alt=",altaz.alt);
        var objectalt = altaz.alt;

        var moonpos = moon_position(d);
        var moonalt = object_altaz(d, moonpos.ra, moonpos.dec, lat, lng).alt;
        moonalt = moon_topocentric_correction(moonalt);
        var UTCdate = new Date(d);
        //console.log("d=",d,",altaz=", altaz, ",moonalt=",moonalt);

        var visiblealt = null;     // target visible
        var softalt = null;        // target below soft horizon
        var hardalt = null;        // target below hard horizon or meridian transit

        var horizon_index = Math.round(altaz.az / 5);

        if (prevaz != null) {
            if ((prevaz > 180 && altaz.az < 180) || // from 360 to 0
                (prevaz < 180 && altaz.az > 180))   // passed 180
            {
                // save meridian crossing
                meridian_index = rowdata.length;
                console.log("meridian_index",meridian_index);
            }
        }
        prevaz = altaz.az;
        if (objectalt > 0) {
            //console.log("objectalt",objectalt,"horizon_index",horizon_index);
            //console.log("soft",horizonSoft[horizon_index],"hard",horizonHard[horizon_index]);
            if (objectalt > horizonSoft[horizon_index]) {
                visiblealt = objectalt;
            } else if (objectalt > horizonHard[horizon_index]) {
                softalt = objectalt;
            } else {
                hardalt = objectalt;
            }
        }
        if (moonalt < 0) {
            moonalt = null;
        }
        var row = [
                    toDateString(UTCdate.getUTCHours())+":"+toDateString(UTCdate.getUTCMinutes()), 
                    //UTCdate,
                    visiblealt,
                    softalt,
                    hardalt,
                    moonalt];
        //console.log("row", row);
        rowdata[rowdata.length] = row;
    }

    if (meridian_index != null) {
        // Mark Meridian crossing as not visible. We use literal 30 minutes clock time here.
        // Maybe it could be done some other way...
        var timer = Math.round((30 * 60 * 1000) / interval);
        var begin = Math.max(meridian_index - timer, 0);
        var end = Math.min(meridian_index + timer, rowdata.length);
        for (var i = begin; i < end; i++) {
            if (rowdata[i][1] != null) {
                rowdata[i][3] = rowdata[i][1];
                rowdata[i][1] = null;
            } else if (rowdata[i][2] != null) {
                rowdata[i][3] = rowdata[i][2];
                rowdata[i][2] = null;
            }
        }

    }

    //for (var i = 0; i < rowdata.length; i++) {
    //    console.log("rowdata", i, rowdata[i])
    //}

    data.addRows(rowdata);

    // problems with timezone if using date, formatter does not solve all problems
    //var formatter = new google.visualization.DateFormat({timeZone: 0});
    //formatter.format(data, 0);

    var options = {
        title: 'Target visibility',
        hAxis: { 
            title: 'Time (UTC)'
            //format: 'HH:mm' 
        },
        vAxis: { title: 'Altitude (degrees)' },
        gridlines: {    // Can't get gridlines to work...
            // count: -1
            //units: { hours: {format: ['HH:MM']}, }
        },
        // minorGridlines: { units: { hours: {format: ['HH:MM']} } },
        series: { 
            0: { color: 'green' },
            1: { color: 'orange', lineDashStyle: [4, 2] },
            2: { color: 'red', lineDashStyle: [2, 2] },
            3: { color: '#1c91c0', lineDashStyle: [4, 1, 2], lineWidth: 1 }
        }
    };

    document.getElementById(dayvisibility_panel).style.height = "400px";
    document.getElementById(dayvisibility_panel).style.width = "700px";
    setGridBackgroundStyle("day-visibility-div");

    // material var chart = new google.charts.Line(document.getElementById(dayvisibility_panel));
    var chart = new google.visualization.LineChart(document.getElementById(dayvisibility_panel));

    // material chart.draw(data, google.charts.Line.convertOptions(options));
    chart.draw(data, options);

    var midnight = suntimes.sunset + (suntimes.sunrise - suntimes.sunset) / 2;

    // We use sun and moon distance in dgrees at midnight to approximate 
    // the moon "phase". I guess there is also a correct way...
    var moon_phase = get_moon_phase(midnight);
    // Moon distance from object at midnight. Distance changes during the night
    // but not much so this should be fine.
    var moonpos_midnight = moon_position(midnight);
    var moon_angle = moon_distance(ra, dec, moonpos_midnight.ra, moonpos_midnight.dec);

    document.getElementById(dayvisibility_panel_text).innerHTML = 
        //"Astronomical twilight start : " + UTCsunset.toUTCString() + "<br>" +
        //"Astronomical twilight end : " + UTCsunrise.toUTCString() + "<br>" +
        "Moon phase: " + Math.floor(moon_phase) + "%<br>" +
        "Moon distance from target: " + Math.floor(moon_angle) + " degrees";

    //console.log("TEST 1990-04-19");
    //moon_position(Date.UTC(1990, 3, 19));
}

function drawYearVisibility() 
{
    console.log("drawYearVisibility");

    var data = new google.visualization.DataTable();
    // get midday in UTC time in ms
    var midday = UTCdate_ms + day_ms/2;

    //data.addColumn('datetime', 'Time'); Can't get this working...
    data.addColumn('date', 'Date');
    data.addColumn('number', 'Visible');            // object altitude
    data.addColumn('number', 'Not visible');        // moon altitude
    data.addColumn('number', 'Moon alt');           // moon altitude

    var interval = day_ms; // day
    
    var ra = target_ra;
    var dec = target_dec;
    
    var lat = location_lat;
    var lng = location_lng;

    var rowdata = [];

    var starttime = midday;
    var endtime = starttime + 365 * day_ms;

    for (var d = starttime; d <= endtime; d = d + interval) {
        var suntimes = sun_rise_set(d, lat, lng, 0);

        // get appriximate midnight
        var midnight = suntimes.sunset + (suntimes.sunrise - suntimes.sunset) / 2;

        var objectalt = object_altaz(midnight, ra, dec, lat, lng).alt;

        var moonpos = moon_position(midnight);
        var moonalt = object_altaz(midnight, moonpos.ra, moonpos.dec, lat, lng).alt;
        moonalt = moon_topocentric_correction(moonalt);

        var visiblealt = null;     // target visible
        var hardalt = null;        // target below 30 degrees

        if (objectalt >= 30) {
            visiblealt = objectalt;
        } else if (objectalt > 0) {
            hardalt = objectalt;
        }
        if (moonalt < 0) {
            moonalt = null;
        }
        var row = [
                new Date(d),
                    visiblealt,
                    hardalt,
                    moonalt];
        rowdata[rowdata.length] = row;
    }

    data.addRows(rowdata);

    var options = {
        title: 'Target visibility at midnight over next 12 months',
        hAxis: { 
            //title: 'Date'
            //format: 'HH:mm' 
        },
        vAxis: { title: 'Altitude (degrees)' },
        gridlines: {    // Can't get gridlines to work...
            // count: -1
            //units: { hours: {format: ['HH:MM']}, }
        },
        // minorGridlines: { units: { hours: {format: ['HH:MM']} } },
        series: { 
            0: { color: 'green' },
            1: { color: 'red', lineDashStyle: [2, 2] },
            2: { color: '#1c91c0', lineDashStyle: [4, 1, 2], lineWidth: 1 }
        }
    };

    document.getElementById(yearvisibility_panel).style.height = "400px";
    document.getElementById(yearvisibility_panel).style.width = "700px";
    setGridBackgroundStyle("year-visibility-div");

    var chart = new google.visualization.LineChart(document.getElementById(yearvisibility_panel));

    chart.draw(data, options);
}

// Find coordinates from Sesame XML output
// or SIMBAD ascii output
function find_coordinates(str)
{
    console.log('find_coordinates');

    var idx = str.indexOf("<jpos>");
    if (idx > 0) {
        // Assume Sesame XML format
        var coord = str.substr(idx+6, 100);
        var idx2 = coord.indexOf("</jpos>");
        if (idx2 == -1) {
            console.log("find_coordinates:failed to get coordinates from '", coord, "', failed at position ", i.toString());
            return false;
        }
        image_target = coord.substr(0, idx2);
    } else {
        // Simbad ascii output
        idx = str.indexOf("J2000");
        if (idx == -1) {
            console.log("find_coordinates:could not find 'J2000'");
            return false;
        }
        str = str.substr(idx+4);
        idx = str.indexOf(":");
        if (idx == -1) {
            console.log("find_coordinates:could not find ':'");
            return false;
        }
        var coord = str.substr(idx+1, 100);
        console.log("find_coordinates:get coordinates from '", coord, "'");
        coord = trim_spaces(coord);
        for (var i = 0; i < coord.length; i++) {
            var c = coord.substr(i,1);
            if ((c < '0' || c > '9') && c != '.' && c != '-' && c != '+' && c != ' ') {
                break;
            }
        }
        if (i < 12) {
            console.log("find_coordinates:failed to get coordinates from '", coord, "', failed at position ", i.toString());
            return false;
        }
        image_target = coord.substr(0, i);
    }
    resolved_name = image_target;

    // change image_target from name to coordinates
    image_target = trim_spaces(image_target);
    console.log("find_coordinates:image_target=", image_target);
    image_target = reformat_coordinates(image_target);
    //document.getElementById(status_text).innerHTML = "Resolved RA/DEC " + image_target;
    document.getElementById(status_text).innerHTML = "";

    resolved_coordinates = image_target;

    return true;
}

// Resolve image coordinates from Simbad database using name
function ViewImageByName()
{
    console.log('ViewImageByName');

    if (resolved_name == image_target && resolved_coordinates != null) {
        // same name already resolved, do not resolve again
        document.getElementById(status_text).innerHTML = "RA/DEC " + resolved_coordinates;
        image_target = resolved_coordinates;
        ViewImageByType();
        return;
    }

    // Simbad ascii, some problems when accessing the site
    // var resolver_url = "https://simbad.u-strasbg.fr/simbad/sim-id?output.format=ASCII&Ident=";
    
    // Mirror of Simbad u-strasbg? Worked when u-strasbg failed.
    // var resolver_url = "http://simbad.cfa.harvard.edu/simbad/sim-id?output.format=ASCII&Ident=";

    // Sesame  uses Simbad, NED and Vizier for resolving. Best documented interface.
    var resolver_url = "https://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame/-oxp/SNV?";

    resolver_url = resolver_url + image_target.replace(/ /g, "+");

    var waitingTimeout = setTimeout(function() { document.getElementById(error_text).innerHTML = "Resolving name..."; }, 1000);

    fetch(resolver_url)
        .then(
            function(response) {
                if (response.status !== 200) {
                    clearTimeout(waitingTimeout);
                    var txt = 'Problem accessing Sesame name resolver. Status Code: ' + response.status;
                    console.log(txt);
                    document.getElementById(error_text).innerHTML = txt;
                    return;
                }
                response.text().then(function(text) {
                    clearTimeout(waitingTimeout);
                    if (find_coordinates(text)) {
                        ViewImageByType();
                    } else {
                        document.getElementById(error_text).innerHTML = "Failed to resolve name " + image_target;
                    }
                })
            }
        )
        .catch(function(err) {
            clearTimeout(waitingTimeout);
            console.log('Problem accessing Sesame name resolver. Fetch Error :', err);
            document.getElementById(error_text).innerHTML = 'Problem accessing Sesame name resolver. Fetch Error :' + err;
        }
    );
}

// Remove leading, trailing and duplicate spaces
function trim_spaces(str)
{
    // replace all whitespace to space
    str = str.replace(/\s/g, " ");
    // remove leading and trailing spaces
    str = str.trim();
    for (var i = 0; i < str.length && str.indexOf('  ') != -1; i++) {
        // remove all duplicate spaces
        str = str.replace(/  /g, " ");
    }
    return str;
}

function decimal_to_mmss(v)
{
    //console.log("decimal_to_mmss, v", v);
    var index = v.indexOf('.');
    if (index == -1) {
        //console.log("decimal_to_mmss, no dot found", v);
        return v;
    }
    var vd = v.substring(index+1);
    //console.log("decimal_to_mmss, vd", vd);
    var d = parseFloat("0."+vd);
    //console.log("decimal_to_mmss, d", d);
    var secs = d * 3600;
    var mins = Math.floor(secs / 60);
    //console.log("decimal_to_mmss, mins", mins);
    secs = secs - mins*60;
    //console.log("decimal_to_mmss, secs", secs);

    var ret = ("0" + v.substr(0, index)).slice(-2) + ':' + ("0" + mins).slice(-2) + ':' + secs.toFixed(2);
    //console.log("decimal_to_mmss, ret", ret);

    return ret;
}

// split [-]XXYYZZ to [-]XX:YY:ZZ
function split_coord(coord)
{
        if (coord.length == 7) {
            return coord.substring(0, 1) + split_coord(coord.substring(1));
        } else {
            return coord.substring(0, 2) + ':' +
                   coord.substring(2, 4) + ':' +
                   coord.substring(4); 
        }
}

function fix_field_lenght(fld)
{
    var sign;

    //console.log("fix_field_lenght:in", fld)

    if (fld.charAt(0) == '-') {
        sign = '-';
        fld = fld.substring(1);
    } else {
        sign = '';
    }
    var s = fld.split('.');
    if (s.length > 1) {
        // We have decimals
        fld = sign + ("0" + s[0]).slice(-2) + '.' + (s[1] + "0").slice(0, 2);
    } else {
        fld = sign + ("0" + fld).slice(-2);
    }
    //console.log("fix_field_lenght:out", fld)
    return fld;
}

// Ensure that format is HH:MM:SS DD:MM:SS, that is,
// two numbers on each field.
function reformat_coordinates_field_lenghts(coord)
{
    var radec = coord.split(" ");
    for (var i = 0; i < radec.length; i++) {
        var fields = radec[i].split(":");
        for (var j = 0; j < fields.length; j++) {
            fields[j] = fix_field_lenght(fields[j]);
        }
        radec[i] = fields[0] + ':' + fields[1] + ':' + fields[2];
    }
    return radec[0] + ' ' + radec[1];
}

// Reformat coordinates to a format HH:MM:SS DD:MM:SS
// Input can be: 
// HH:MM:SS DD:MM:SS, HH MM SS DD MM SS, 
// HH:MM:SS/DD:MM:SS, HH MM SS/DD MM SS,
// HHMMSS DDMMSS
// HH.dec DD.dec
function reformat_coordinates(coord)
{
    // number, assume coordinates
    coord = trim_spaces(coord);
    console.log('reformat_coordinates=', coord);
    var numbers = coord.split('/');
    if (numbers.length == 2) {
        coord = trim_spaces(numbers[0] + ' ' + numbers[1]);
        console.log('reformat_coordinates, split by /', coord);
    }
    numbers = coord.split(' ');
    console.log('reformat_coordinates, numbers.length=', numbers.length);
    if (numbers.length == 2) {
        var ra = numbers[0];
        var dec = numbers[1];
        if (ra.split(':').length == 1) {
            if (ra.indexOf('.') == -1 && dec.indexOf('.') == -1) {
                // no dots, assume HHMMSS DDMMSS
                coord = split_coord(ra) + ' ' + split_coord(dec);
                console.log('reformat_coordinates, length 2, assume HHMMSS DDMMSS', coord);
            } else {
                // assume HH.dec DD.dec, convert to HH:MM:SS DD:MM:SS
                coord = decimal_to_mmss(ra) + ' ' + decimal_to_mmss(dec);
                console.log('reformat_coordinates, length 2, assume correct HH.dec DD.dec', coord);
            }
        } else {
            // assume already correct format HH:MM:SS DD:MM:SS
            console.log('reformat_coordinates, length 2, assume correct format HH:MM:SS DD:MM:SS', coord);
        }
    } else if (numbers.length == 6) {
        // separated by space, add colons
        coord = numbers[0] + ':' + numbers[1] + ':' + numbers[2] + ' ' +
                numbers[3] + ':' + numbers[4] + ':' + numbers[5];
        console.log('reformat_coordinates, length "+numbers.length+", use as-is', coord);
    } else if (numbers.length == 5) {
        // badly formatted SIMBAD case, assume zero last number, separated by space, add colons
        coord = numbers[0] + ':' + numbers[1] + ':' + numbers[2] + ' ' +
                numbers[3] + ':' + numbers[4] + ':' + 0;
        console.log('reformat_coordinates, length "+numbers.length+", use as-is', coord);
    } else {
        // use as-is
        console.log('reformat_coordinates, length 6, reformat', coord);
    }
    coord = reformat_coordinates_field_lenghts(coord);
    console.log('reformat_coordinates, field lengths fixed', coord);
    return coord;
}

// target field action handler
// we clear catalog list selection if target is changed
function ViewTarget()
{
    catalogDiv_select.value = '';
    ViewImage(0);
}

function update_telescope_service_list()
{
    console.log('update_telescope_service_list');

    var x = document.getElementById("current-telescope-service");
    while (x.length > 0) {
        x.remove(0);
    }

    // Update list of telescopes
    for (i = 0; i < telescope_services.length; i++) {
        var option = document.createElement("option");
        option.text = telescope_services[i].name;
        x.add(option);
    }
    if (current_telescope_service_selected_index > 0) {
        x.selectedIndex = current_telescope_service_selected_index;
        current_telescope_service_selected_index = 0;
    }
}

function update_telescope_list(new_name)
{
    console.log('update_telescope_list');

    var x = document.getElementById("current-telescope");
    while (x.length > 0) {
        x.remove(0);
    }

    // Find the service
    for (var i = 0; i < telescope_services.length; i++) {
        if (telescope_services[i].name == new_name) {
            console.log('update_telescope_list: current_telescope_service', current_telescope_service.name);
            current_telescope_service = telescope_services[i];
            break;
        }
    }
    // Update list of telescopes
    current_telescope = current_telescope_service.telescopes[0];
    for (i = 0; i < current_telescope_service.telescopes.length; i++) {
        var option = document.createElement("option");
        option.text = current_telescope_service.telescopes[i].name;
        x.add(option);
    }
    if (current_telescope_selected_index > 0) {
        x.selectedIndex = current_telescope_selected_index;
        current_telescope_selected_index = 0;
    }
}

function skip_slooh_catalog(service, catalog)
{
    return service.name != "Slooh" && catalog.source == "slooh";
}

function update_catalog_list()
{
    console.log('update_catalog_list');

    var x = document.getElementById("catalog-selection");
    while (x.length > 0) {
        x.remove(0);
    }
    current_catalog = null;
    for (i = 0; i < catalogs.length; i++) {
        if (skip_slooh_catalog(current_telescope_service, catalogs[i])) {
            // Skip Slooh catalog on other services
            continue;
        }
        if (current_catalog == null) {
            current_catalog = catalogs[i];
        }
        if (catalogs[i].targets != null && catalogs[i].AladinCatalog == null) {
            addJsonToAladinCatalog(catalogs[i]);
        }
        var option = document.createElement("option");
        option.text = catalogs[i].name;
        x.add(option);
    }
}

function getFov(fov)
{
    return (fov*60.0)/3600.0;
}

// Main function to view image. Get parameters
// and call correct view function
// Values for oper_
//      1 - Telescope service changed
//      2 - Telescope changed
function ViewImage(oper)
{
    console.log('ViewImage', oper);

    document.getElementById(status_text).innerHTML = "";
    document.getElementById(error_text).innerHTML = "";

    clearOldImage();

    // get current date
    var view_date = document.getElementById("view_date").value;
    var curdate = new Date(view_date);
    if (curdate == null || isNaN(curdate.valueOf())) {
        document.getElementById(error_text).innerHTML = "Invalid ISO format date (YYYY-MM-DD) " + view_date;
        return;
    }
    checkFilterChanged();
    checkFilterTimeChanged();

    //console.log("curdate", curdate);
    UTCdate_ms = Date.UTC(parseInt(view_date.substr(0, 4)), parseInt(view_date.substr(5, 2))-1, 
                          parseInt(view_date.substr(8, 2)));

    if (catalog_date != UTCdate_ms) {
        // time changed, reset catalog view list
        console.log("ViewImage, date changed, reset catalog view");
        catalog_date = UTCdate_ms;
        catalog_reset();
    }

    if (oper == 1) {
        // Telescope service changed
        var telescope_service_name = document.getElementById("current-telescope-service").value;
        /* Update list of telescopes. */
        update_telescope_list(telescope_service_name);
        update_catalog_list();
        catalog_filters_changed = true;
    }

    if (oper == 2) {
        // Telescope is changed
        var telescope_name = document.getElementById("current-telescope").value;
        for (var i = 0; i < current_telescope_service.telescopes.length; i++) {
            if (telescope_name == current_telescope_service.telescopes[i].name) {
                current_telescope = current_telescope_service.telescopes[i];
            }
        }
    }

    img_fov = document.getElementById("overlap_percentage").value;
    img_fov = 1 - img_fov / 100;

    // Update processing variables based on telescope
    fov_x = current_telescope.fov_x;
    fov_y = current_telescope.fov_y;
    location_lat = current_telescope.lat;
    location_lng = current_telescope.lng;
    horizonHard = current_telescope.horizonHard;
    horizonSoft = current_telescope.horizonSoft;
    telescope_location = current_telescope.name;

    var target_name;

    init_catalog_view_list();

    console.log("horizonHard[0]", horizonHard[0]);

    image_target = document.getElementById("target").value;
    image_target = trim_spaces(image_target);
    console.log('image_target=', image_target);
    image_target_list = [];

    showWiki();

    var c = image_target.substr(0,1);
    if ((c >= '0' && c <= '9') || c == '-' || c == '+') {
        console.log('image_target is number');
        image_target_list = image_target.split(',');
        for (var i = 0; i < image_target_list.length; i++) {
            image_target_list[i] = reformat_coordinates(image_target_list[i]);
        }
        console.log('image_target_list', image_target_list);
        image_target = image_target_list[0];
        ViewImageByType();
    } else {
        console.log('image_target is name');
        // try to resolve target as a name
        ViewImageByName();
    }

    showWeatherForecast();
}

function ViewImageByType()
{
    console.log('ViewImageByType');
    if (!get_image_target_ra_dec()) {
        document.getElementById(error_text).innerHTML = "Failed to parse target RA/DEC";
        return;
    }
    if (document.getElementById("grid_type").value == 'panels') {
        ViewPanels();
    } else {
        // material google.charts.load('current', {'packages':['line']});
        google.charts.load('current', {'packages':['corechart']});
        google.charts.setOnLoadCallback(drawDayVisibilityandGrid);
        google.charts.setOnLoadCallback(drawYearVisibility);
    }
}

function degrees_to_radians(degrees)
{
    var pi = Math.PI;
    return degrees * (pi/180);
}

function clearOldImage()
{
    for (var x = 0; x < 5; x++) {
        for (var y = 0; y < 5; y++) {
            var panelid = y.toString() + x.toString();
            var aladinpanel = "aladin-lite-div-"+panelid;
            document.getElementById(aladinpanel).innerHTML = "";
            document.getElementById(aladinpanel).style.borderStyle = "none";;
            document.getElementById(aladinpanel).style.height = "0px";
            document.getElementById(aladinpanel).style.width = "0px";
            document.getElementById("panel-text-"+panelid).innerHTML = "";
            setHiddenBackgroundStyle(aladinpanel);
        }
    }
}

function OpenNGC_type_to_typename(type, target_list)
{
    // Map OpenNSC types to a more descriptive text
    if (type == '*')   return('Star');
    if (type == '**')   return('Double star');
    if (type == '*Ass')   return('Association of stars');
    if (type == 'OCl')   return('Open Cluster');
    if (type == 'GCl')   return('Globular Cluster');
    if (type == 'Cl+N')   return('Star cluster + Nebula');
    if (type == 'G')   return('Galaxy');
    if (type == 'GPair')   return('Galaxy Pair');
    if (type == 'GTrpl')   return('Galaxy Triplet');
    if (type == 'GGroup')   return('Group of galaxies');
    if (type == 'PN')   return('Planetary Nebula');
    if (type == 'HII')   return('HII Ionized region');
    if (type == 'DrkN')   return('Dark Nebula');
    if (type == 'EmN')   return('Emission Nebula');
    if (type == 'Neb')   return('Nebula');
    if (type == 'RfN')   return('Reflection Nebula');
    if (type == 'SNR')   return('Supernova remnant');
    if (type == 'Nova')   return('Nova star');
    if (type == 'NonEx')   return('Nonexistent object');
    if (type == 'Dup')   return('Duplicated object (see NGC or IC columns to find the master object)');
    if (type == 'Other')   {
        if (target_list) {
            return('');
        } else {
            return('Other classification (see object notes)');
        }
    }
    
    // Slooh type 
    return(type);
}

function addTabRow(tab, v1, v2)
{
    return tab + "<TR><TD>" + v1 + "</TD><TD>" + v2 + "</TD></TR>";
}

function initAladin(aladin_fov, aladin_target)
{
    console.log('initAladin', aladin_target);
    var aladin = null;
    if (A) {
        aladin = A.aladin('#aladin-lite-div-00', {survey: "P/DSS2/color", fov:aladin_fov, target:aladin_target,
                           showReticle:false, showZoomControl:false, showFullscreenControl:true, 
                           showLayersControl:true, showGotoControl:false, 
                           showControl: false, cooFrame: "J2000", showFrame: false});
    } else {
        document.getElementById(image_panel).style.height = "50px";
        document.getElementById(image_panel).innerHTML = "<p>Could not access Aladin Sky Atlas</p>";
    }
    if (aladin) {
        for (var i = 0; i < catalogs.length; i++) {
            if (catalogs[i].AladinCatalog != null) {
                if (!skip_slooh_catalog(current_telescope_service, catalogs[i])) {
                    aladin.addCatalog(catalogs[i].AladinCatalog);
                }
            }
        }
    }

    // define function triggered when an object is clicked
    var objClicked;
    if (aladin) {
        aladin.on('objectClicked', function(object) {
            if (object) {
                objClicked = object;
                object.select();
                var tab = "<BR><TABLE>";
                tab = addTabRow(tab, "Name", object.data.name);
                tab = addTabRow(tab, "Type", object.data.info.type);
                tab = addTabRow(tab, "RA/DEC",  (object.ra*degToHours).toFixed(5) + ' ' + object.dec.toFixed(5));
                tab = addTabRow(tab, "Constellation", object.data.info.constellation);
                tab = addTabRow(tab, "Magnitude", object.data.info.mag);
                tab = addTabRow(tab, "Distance (Mly)", object.data.info.distance);
                tab = addTabRow(tab, "Notes", object.data.info.notes);
                tab = addTabRow(
                        tab, 
                        "Url", 
                        '<a href="http://simbad.u-strasbg.fr/simbad/sim-id?Ident='+object.data.name.replace(/ /g, "+")+'">SIMBAD</a>');
            
                tab = tab + "</TABLE>";
                console.log('aladin objectClicked', tab);
                alt_wikitext = tab;
                showWikiTarget(object.data.wikiname);
                alt_wikitext = null;
            } else {
                console.log('aladin objectClicked, no object');
            }
        });
    }
    return aladin;
}

function ViewGrid()
{
    console.log('ViewGrid');

    document.getElementById(image_panel).style.height = "700px";
    document.getElementById(image_panel).style.width = "700px";
    setGridBackgroundStyle("target-image-div");

    grid_type = document.getElementById("grid_type").value;

    var grid_size_x = parseInt(document.getElementById("size_x").value);
    var grid_size_y = parseInt(document.getElementById("size_y").value);
    if (grid_size_x == 1 && grid_size_y == 1) {
        grid_type = "fov";
    }
    if (grid_type == "mosaic") {
        size_x = grid_size_x / 2 - 0.5;
        size_y = grid_size_y / 2 - 0.5;
    } else {
        size_x = 1;
        size_y = 1;
        grid_size_x = 3;
        grid_size_y = 3;
    }

    // Show image and get coordinates from there to
    // calculate grid boxes.
    var aladin_fov;
    if (grid_type == "mosaic") {
        if (grid_size_x > grid_size_y) {
            aladin_fov = (grid_size_x+0.2)*fov_x;
        } else {
            aladin_fov = (grid_size_y+0.2)*fov_x;
        }
    } else {
        aladin_fov = 1.2*fov_x;
    }

    var aladin = initAladin(aladin_fov, image_target);

    var radec = null;
    if (aladin) {
        radec = aladin.getRaDec();
    }

    console.log("center RaDec = ", radec);

    var ra = radec[0];
    var dec = radec[1];

    var x;
    var y;
    var row = size_y;
    var col;
    var panel_radec = [];
    for (x = 0; x < grid_size_x; x++) {
        panel_radec[x] = [];
    }
    y = 0;
    while (row >= -size_y) {
        var row_dec = dec + row * img_fov * fov_y;
        col = size_x;
        x = 0;
        while (col >= -size_x) {
            var col_ra = ra + col * (img_fov * fov_x * (1/Math.cos(degrees_to_radians(Math.abs(row_dec)))));

            console.log("panel ra/dec=", col_ra, "/", row_dec);

            // now center ra/dec is col_ra/row_dec
            // calculate corners
            var row_dec1 = row_dec + fov_y/2;
            var row_dec2 = row_dec - fov_y/2;
            var col_ra1 = ra + col * (img_fov * fov_x * (1/Math.cos(degrees_to_radians(Math.abs(row_dec1)))));
            var col_ra2 = ra + col * (img_fov * fov_x * (1/Math.cos(degrees_to_radians(Math.abs(row_dec2)))));
            var col_ra1_delta = ((fov_x/2) * (1/Math.cos(degrees_to_radians(Math.abs(row_dec1)))));
            var col_ra2_delta = ((fov_x/2) * (1/Math.cos(degrees_to_radians(Math.abs(row_dec2)))));

            var panel = [
                [col_ra1-col_ra1_delta, row_dec1], 
                [col_ra1+col_ra1_delta, row_dec1], 
                [col_ra2+col_ra2_delta, row_dec2], 
                [col_ra2-col_ra2_delta, row_dec2], 
                [col_ra1-col_ra1_delta, row_dec1]
            ];

            //console.log("panel = ", panel);

            var line_color = '#ee2345';

            if ((grid_type == "mosaic" || (x == 1 && y == 1)) && aladin) {
                var overlay = A.graphicOverlay({color: line_color, lineWidth: 2});
                aladin.addOverlay(overlay);
                overlay.add(A.polyline(panel));
            }
            col = col - 1;

            var col_ra_hours = col_ra * degToHours;

            if (grid_type == "mosaic") {
                if (current_telescope_service.radec_format == 0) {
                    panel_radec[x][y] = col_ra_hours.toFixed(5) + 
                                        " " + row_dec.toFixed(5);
                } else {
                    panel_radec[x][y] = reformat_coordinates(
                                            col_ra_hours.toFixed(5) + " " + row_dec.toFixed(5));
                }
            } else {
                /* We show only one scope FoV (default) so show
                 * coordinates in different formats.
                 */
                panel_radec[x][y] = "RA/DEC " + 
                                    col_ra_hours.toFixed(5) + " " + row_dec.toFixed(5) + ", " + 
                                    ra.toFixed(5) + " " + dec.toFixed(5) + ", " +
                                    image_target;
            }
            x = x + 1;
        }
        row = row - 1;
        y = y + 1;
    }
    if (grid_type == "mosaic") {
        var tab = document.createElement("TABLE");
        tab.style.width = "100%";
        tab.style.borderCollapse="collapse";
        for (y = 0; y < grid_size_y; y++) {
            var tabrow = document.createElement("TR");
            tab.appendChild(tabrow);
            for (x = 0; x < grid_size_x; x++) {
                var tabdata = document.createElement("TD");
                var celltext = document.createTextNode(panel_radec[x][y]);
                tabdata.style.border = "1px solid #dddddd";
                tabdata.style.padding = "4px";
                tabdata.appendChild(celltext);
                tabrow.appendChild(tabdata);
            }
        }
        document.getElementById(image_panel_text).appendChild(tab);
    } else {
        document.getElementById(image_panel_text).innerHTML = panel_radec[1][1];
    }
    if (version_text) {
        // use wiki panel to show version info
        var lines = version_text.split('\n');
        var visible_text = '<br>';
        for (var i = 0; i < 35 && i < lines.length; i++) {
            visible_text = visible_text + lines[i] + '<br>';
        }
        if (i < lines.length) {
            visible_text = visible_text + '...<br>';
        }
        document.getElementById(wiki_panel).style.height = "300px";
        document.getElementById(wiki_panel).style.width = wiki_panel_width;
        document.getElementById(wiki_panel).innerHTML = visible_text;
        // show only once, next time it is not shown
        version_text = null;    
    }
}

function ViewGridFromList(coordinates)
{
    console.log('ViewGridFromList');

    document.getElementById(image_panel).style.height = "700px";
    document.getElementById(image_panel).style.width = "700px";
    setGridBackgroundStyle("target-image-div");

    var grid_size_x = coordinates.length;
    var grid_size_y = coordinates.length;
    size_x = grid_size_x / 2 - 0.5;
    size_y = grid_size_y / 2 - 0.5;

    // Show image and get coordinates from there to
    // calculate grid boxes.
    var aladin_fov;
    if (grid_size_x > grid_size_y) {
        aladin_fov = (grid_size_x+0.2)*fov_x;
    } else {
        aladin_fov = (grid_size_y+0.2)*fov_x;
    }

    var aladin = initAladin(aladin_fov, coordinates[0])
    var radec = null;

    console.log("center RaDec = ", coordinates[0]);

    for (var i = 0; i < coordinates.length; i++) {
        radec = get_ra_dec(coordinates[i]);
        var col_ra = radec[0];
        var row_dec = radec[1];

        console.log("panel "+i+" ra/dec=", col_ra, "/", row_dec);

        // calculate corners
        var row_dec1 = row_dec + fov_y/2;
        var row_dec2 = row_dec - fov_y/2;
        var col_ra1 = col_ra;
        var col_ra2 = col_ra;
        var col_ra1_delta = ((fov_x/2) * (1/Math.cos(degrees_to_radians(Math.abs(row_dec1)))));
        var col_ra2_delta = ((fov_x/2) * (1/Math.cos(degrees_to_radians(Math.abs(row_dec2)))));

        var panel = [
            [col_ra1-col_ra1_delta, row_dec1], 
            [col_ra1+col_ra1_delta, row_dec1], 
            [col_ra2+col_ra2_delta, row_dec2], 
            [col_ra2-col_ra2_delta, row_dec2], 
            [col_ra1-col_ra1_delta, row_dec1]
        ];

        var line_color = '#ee2345';
        if (aladin) {
            var overlay = A.graphicOverlay({color: line_color, lineWidth: 2});
            aladin.addOverlay(overlay);
            overlay.add(A.polyline(panel));
        }
    }
}

function ViewPanels()
{
    console.log('ViewPanels');

    var grid_size_x = parseInt(document.getElementById("size_x").value);
    var grid_size_y = parseInt(document.getElementById("size_y").value);
    if (grid_size_x == 1 && grid_size_y == 1) {
        ViewGrid();
        return;
    }
    if (grid_size_x > 5) {
        document.getElementById(error_text).innerHTML = "Max size in panels view is 5x5";
        grid_size_x = 5;
    }
    if (grid_size_y > 5) {
        document.getElementById(error_text).innerHTML = "Max size in panels view is 5x5";
        grid_size_y = 5;
    }

    wikiReset();

    for (var x = 0; x < grid_size_x; x++) {
        for (var y = 0; y < grid_size_y; y++) {
            var panelid = y.toString() + x.toString();
            var aladinpanel = "aladin-lite-div-"+panelid;
            document.getElementById(aladinpanel).style.height = "300px";
            document.getElementById(aladinpanel).style.width = "300px";
            setPanelBackgroundStyle(aladinpanel);
        }
        setPanelBackgroundStyle("day-visibility-div");
        setPanelBackgroundStyle("year-visibility-div");
        setPanelBackgroundStyle("target-image-div");
    }

    size_x = grid_size_x / 2 - 0.5;
    size_y = grid_size_y / 2 - 0.5;

    console.log("image_target=" + image_target);
    var ra = target_ra;
    var dec = target_dec;

    var i = 0;
    var row = size_y;
    var col;
    var row_number = 0;
    var y = 0;
    while (row >= -size_y) {
        var row_dec = dec + row * img_fov * fov_y;
        col = size_x;
        var panel_number = 5 * row_number;
        var x = 0;
        while (col >= -size_x) {
            var col_ra = ra + col * (img_fov * fov_x * (1/Math.cos(degrees_to_radians(Math.abs(row_dec)))));
            // convert from degrees to hours
            col_ra = col_ra * degToHours;

            var point_ra_hour = Math.floor(col_ra);
            var point_ra_sec = (Math.abs(col_ra) - Math.abs(point_ra_hour)) * 3600;
            var point_ra_min = Math.floor(point_ra_sec / 60);
            point_ra_sec = point_ra_sec - point_ra_min * 60;
    
            var point_dec_hour = Math.floor(row_dec);
            var point_dec_sec = (Math.abs(row_dec) - Math.abs(point_dec_hour)) * 3600;
            var point_dec_min = Math.floor(point_dec_sec / 60);
            point_dec_sec = point_dec_sec - point_dec_min * 60;
    
            aladin_target_str = point_ra_hour.toString() + ":" + point_ra_min.toString() + ":" + point_ra_sec.toFixed(2) + " ";
            aladin_target_str = aladin_target_str + point_dec_hour.toString() + ":" + point_dec_min.toString() + ":" + point_dec_sec.toFixed(2);

            var panel_id = 'aladin-lite-div-'+y.toString()+x.toString();
            if (fov_x != fov_y) {
                var height = 300 * fov_y / fov_x;
                document.getElementById(panel_id).style.height = Math.floor(height).toString() + "px";
            } else {
                document.getElementById(panel_id).style.height = "300px";
            }
            if (A) {
                aladin = A.aladin('#'+panel_id, {survey: "P/DSS2/color", fov:fov_x, target: aladin_target_str,
                                    showReticle:false, showZoomControl:false, showFullscreenControl:false, 
                                    showLayersControl:false, showGotoControl:false,
                                    showControl: false, cooFrame: "J2000", showFrame: false});
            }
            document.getElementById("panel-text-"+y.toString()+x.toString()).innerHTML = (i+1).toString() + " RA/DEC " + col_ra.toFixed(5) + " " + row_dec.toFixed(5);
            col = col - 1;
            i = i + 1;
            panel_number = panel_number + 1;
            x = x + 1;
        }
        row = row - 1;
        row_number = row_number + 1;
        y = y + 1;
    }
}

function addJsonToAladinCatalog(cat)
{
    cat.AladinCatalog = A.catalog({name: cat.name, labelColumn: 'name', displayLabel: true, labelColor: cat.color, labelFont: '12px sans-serif'});
    cat.AladinCatalog.hide();

    for (var i = 0; i < cat.targets.length; i++) {
        //   0      1     2      3       4      5       6      7       8
        // ["CAT", "RA", "DEC", "TYPE", "CON", "BMAG", "DST", "NAME", "INFO"]
        var catname = cat.targets[i][0];    // CAT
        var extname = cat.targets[i][7];    // NAME
        var dispname;
        if (extname != "") {
            dispname = catname + ', ' + extname;
        } else {
            dispname = catname;
        }
        if (i == 0) {
            console.log("addJsonToAladinCatalog:add", cat.targets[i], name);
        }

        cat.AladinCatalog.addSources(A.source(cat.targets[i][1] * hoursToDeg, cat.targets[i][2], 
                        {
                            name: dispname, 
                            wikiname: catname,
                            info: { 
                                    type: cat.targets[i][3],
                                    constellation: cat.targets[i][4],
                                    mag: cat.targets[i][5],
                                    distance: cat.targets[i][6],
                                    notes: cat.targets[i][8]
                            }
                        } ));
    }
}

function processJsonCatalog(cat, json)
{
    console.log("Create " + cat.name + " catalog");

    cat.targets = json.data;

    addJsonToAladinCatalog(cat);
}

function loadCatalog(cat)
{
    console.log("Load catalog " + cat.name + " from " + cat.url);

    fetch(cat.url)
        .then(
            function(response) {
                if (response.status !== 200) {
                    console.log('Problem accessing catalog ' + cat.name + '. Status Code: ' + response.status);
                    return;
                }
                response.json().then(function(jsonData) {
                    processJsonCatalog(cat, jsonData);
                    update_catalog_list();
                })
            }
        )
        .catch(function(err) {
            console.log('Problem accessing catalog ' + cat.name + '. Fetch Error :', err);
        }
    );
}

function load_and_init_catalogs()
{
    if (!A) {
        console.log("load_and_init_catalogs:Aladin not available");
        return;
    }

    console.log("load_and_init_catalogs");

    for (var i = 0; i < catalogs.length; i++) {
        if (catalogs[i].targets == null) {
            loadCatalog(catalogs[i]);
        }
    }
}

// create select object
function create_catalog_select_list(name, list)
{
    console.log("create_catalog_select_list");
    
    var x = document.createElement("SELECT");
    x.setAttribute("id", name);

    for (var i = 0; i < list.length; i++) {
        if (i < 3) {
            console.log("list[i]", list[i]);
        }
        var y = document.createElement("option");
        y.setAttribute("value", list[i][0]);
        var t = document.createTextNode(list[i][1]);
        y.appendChild(t);
        x.appendChild(y);
    }
    return x;
}

// create list filtered by visibility during the night
function filter_visible_catalog_items(cat, lat, lng)
{
    var midnight;
    var aa1;
    var aa2;
    var aa3;
    var aa4;
    var aa5;
    var moonFilter = catalogFilterMoon;

    if (cat == null || cat.targets == null) {
        console.log("filter_visible_catalog_items:cat == null or cat.targets == null");
        return { list: [['', ''], ['', 'No data loaded']] };
    }

    if (catalog_filter_time == null) {
        console.log("filter_visible_catalog_items:use whole night");
        var midday = UTCdate_ms + day_ms/2;
        var suntimes = sun_rise_set(midday, lat, lng, 0);
        midnight = suntimes.sunset + (suntimes.sunrise - suntimes.sunset) / 2;
    } else {
        console.log("filter_visible_catalog_items:use specific time");
        midnight = UTCdate_ms + catalog_filter_time;
    }
    var fl = [];
    fl[fl.length] = ['', ''];

    // if object altitude is above catalogFilterDegrees degrees in any of the following
    // points during the night we add it to list
    aa1 = object_altitude_init(midnight, lat, lng);
    var thisfilterdate = new Date(midnight);
    console.log("filter date 1:", thisfilterdate.toUTCString());
    var moonpos = moon_position(midnight);
    // Check moon altitude at given time. If it is below horizon we do not filter with moon.
    var moonalt = object_altaz(midnight, moonpos.ra, moonpos.dec, lat, lng).alt;
    moonalt = moon_topocentric_correction(moonalt);
    if (moonalt < 0) {
        moonFilter = null;
    }
    if (catalog_filter_time == null) {
        // no time filter, use also times 2 and 4 hours before and after midnight
        var d = midnight+2*hour_ms;
        aa2 = object_altitude_init(d, lat, lng);
        thisfilterdate = new Date(d);
        moonalt = object_altaz(d, moonpos.ra, moonpos.dec, lat, lng).alt;
        moonalt = moon_topocentric_correction(moonalt);
        if (moonalt < 0) {
            moonFilter = null;
        }
        console.log("filter date 2:", thisfilterdate.toUTCString());
        d = midnight-2*hour_ms;
        aa3 = object_altitude_init(d, lat, lng);
        thisfilterdate = new Date(d);
        // check moon altitude at this time
        moonalt = object_altaz(d, moonpos.ra, moonpos.dec, lat, lng).alt;
        moonalt = moon_topocentric_correction(moonalt);
        if (moonalt < 0) {
            moonFilter = null;
        }
        console.log("filter date 3:", thisfilterdate.toUTCString());
        var d = midnight+4*hour_ms;
        aa4 = object_altitude_init(d, lat, lng);
        thisfilterdate = new Date(d);
        moonalt = object_altaz(d, moonpos.ra, moonpos.dec, lat, lng).alt;
        moonalt = moon_topocentric_correction(moonalt);
        if (moonalt < 0) {
            moonFilter = null;
        }
        console.log("filter date 4:", thisfilterdate.toUTCString());
        d = midnight-4*hour_ms;
        aa5 = object_altitude_init(d, lat, lng);
        thisfilterdate = new Date(d);
        moonalt = object_altaz(d, moonpos.ra, moonpos.dec, lat, lng).alt;
        moonalt = moon_topocentric_correction(moonalt);
        if (moonalt < 0) {
            moonFilter = null;
        }
        console.log("filter date 5:", thisfilterdate.toUTCString());
    }
    for (var i = 0; i < cat.targets.length; i++) {
        //   0      1     2      3       4      5       6      7       8
        // ["CAT", "RA", "DEC", "TYPE", "CON", "BMAG", "DST", "NAME", "INFO"]
        var ra = cat.targets[i][1];
        var dec = cat.targets[i][2];
        var alt;
        var addToList = false;
        if (catalogFilterDegrees != null) {
            alt = object_altitude_get(aa1, ra, dec);
            if (catalog_filter_time == null) {
                // no time filter, use also times 2 and 4 hours before and after midnight
                if (alt < catalogFilterDegrees) {
                    alt = object_altitude_get(aa2, ra, dec);
                }
                if (alt < catalogFilterDegrees) {
                    alt = object_altitude_get(aa3, ra, dec);
                }
                if (alt < catalogFilterDegrees) {
                    alt = object_altitude_get(aa4, ra, dec);
                }
                if (alt < catalogFilterDegrees) {
                    alt = object_altitude_get(aa5, ra, dec);
                }
            }
        }
        if (catalogFilterDegrees == null || alt >= catalogFilterDegrees) {
            // we passed altitude filter
            addToList = true;
            if (moonFilter != null) {
                // check for distance from moon
                var moon_angle = moon_distance(ra, dec, moonpos.ra, moonpos.dec);
                if (moon_angle < moonFilter) {
                    addToList = false;
                }
            }
        }
        if (addToList) {
            //   0      1     2      3       4      5       6      7       8
            // ["CAT", "RA", "DEC", "TYPE", "CON", "BMAG", "DST", "NAME", "INFO"]
            // -> RA DEC, CAT+NAME+TYPE
            var name = cat.targets[i][0];                   // CAT
            if (cat.targets[i][7] != "") {
                name = name + ', ' + cat.targets[i][7];     // NAME
            }
            if (cat.targets[i][3] != "") {
                name = name + ', ' + cat.targets[i][3];     // TYPE
            }
            if (fl.length == 0) {
                console.log("filter_visible_catalog_items:add", cat.targets[i], name);
            }
            fl[fl.length] = [ 
                cat.targets[i][1].toFixed(5) + ' ' +  + cat.targets[i][2].toFixed(5),
                name
            ];
        }
    }
    return { list: fl };
}

function init_catalog_view_list()
{
    if (!catalog_filters_changed) {
        console.log("init_catalog_view_list:no change");
        return;
    }

    console.log("init_catalog_view_list", current_catalog.name);

    wikiReset();
    catalog_index = null;

    if (catalogDiv_select != null) {
        // remove old list
        console.log("init_catalog_view_list:remove old select list");
        document.getElementById("catalogDiv").removeChild(catalogDiv_select);
        document.getElementById("catalogDiv").removeChild(catalog_text);
    }

    current_catalog_filtered_list = filter_visible_catalog_items(current_catalog, location_lat, location_lng);
    if (current_catalog_filtered_list != null) {

        catalogDiv_select = create_catalog_select_list('catalogDiv_select', current_catalog_filtered_list.list);
        catalogDiv_select.onchange = function() { 
                                    // Get coordinates from catalogDiv_select.value and put them
                                    // to target box so we will show the target
                                    document.getElementById("target").value = catalogDiv_select.value;
                                    catalog_index = catalogDiv_select.selectedIndex;
                                    if (catalog_index == 0) {
                                        catalog_index = null;
                                    } else {
                                        catalog_index = catalog_index - 1;
                                    }
                                    ViewImage(0);
                                };

        document.getElementById("catalogDiv").appendChild(catalogDiv_select);

        if (current_catalog.targets == null) {
            catalog_text = document.createTextNode(' 0/0');
        } else {
            catalog_text = document.createTextNode(' ' + (current_catalog_filtered_list.list.length-1).toString() + 
                                                    '/' + current_catalog.targets.length.toString());
        }
        document.getElementById("catalogDiv").appendChild(catalog_text);

        catalog_filters_changed = false;
    }
}

function checkFilterChanged()
{
    var ret = false;
    var newcatalog = document.getElementById("catalog-selection").value;
    var newvalue = document.getElementById("catalogFilterDegrees").value;
    var newfilter;
    if (current_catalog.name != newcatalog) {
        console.log("checkFilterChanged:catalog changed to", newcatalog);
        for (var i = 0; i < catalogs.length; i++) {
            if (catalogs[i].name == newcatalog) {
                current_catalog = catalogs[i];
            }
        }
        ret = true;
    }
    if (newvalue == 'all') {
        newfilter = null;
    } else {
        newfilter = parseInt(newvalue);
    }
    if (catalogFilterDegrees != newfilter) {
        catalogFilterDegrees = newfilter;
        console.log("checkFilterChanged:catalogFilterDegrees", catalogFilterDegrees);
        ret = true;
    }
    newvalue = document.getElementById("catalogFilterMoon").value;
    if (newvalue == 'all') {
        newfilter = null;
    } else {
        newfilter = parseInt(newvalue);
    }
    if (catalogFilterMoon != newfilter) {
        catalogFilterMoon = newfilter;
        console.log("checkFilterChanged:catalogFilterMoon", catalogFilterMoon);
        ret = true;
    }
    if (ret) {
        catalog_reset();
    }
    return ret;
}

function filterChanged()
{
    console.log("checkFifilterChanged");
    if (checkFilterChanged()) {
        ViewImage(0);
    }
}

function checkFilterTimeChanged()
{
    var newvalue = document.getElementById("catalogFilterTime").value;
    var UTCtime_ms;
    console.log("checkFilterTimeChanged, time value", newvalue);
    if (newvalue == '') {
        UTCtime_ms = null;
        console.log("checkFilterTimeChanged, no time given");
    } else {
        var hhmm = newvalue.split(':');
        if (hhmm.length != 2) {
            document.getElementById(error_text).innerHTML = "Invalid ISO format time (HH:MM)";
            return;
        }
        UTCtime_ms = (parseInt(hhmm[0]) * 60 * 60 + parseInt(hhmm[1]) * 60) * 1000;
        if (UTCtime_ms == null) {
            document.getElementById(error_text).innerHTML = "Invalid ISO format time (HH:MM)";
            return;
        }
        console.log("checkFilterTimeChanged, time ", UTCtime_ms);
    }
    if (catalog_filter_time != UTCtime_ms) {
        // time changed, reset view list
        console.log("checkFilterTimeChanged, time changed, reset catalog view");
        catalog_filter_time = UTCtime_ms;
        catalog_reset();
        return true;
    } else {
        return false;
    }
}

function filterTimeChanged()
{
    console.log("filterTimeChanged");
    if (checkFilterTimeChanged()) {
        ViewImage(0);
    }
}

function catalog_reset()
{
    catalog_filters_changed = true;
    catalog_index = null;

    wikiReset();
}

var wikiIframe = null;

function wikiReset()
{
    if (wikiIframe != null) {
        if (wikiIframe.parentNode) {
            wikiIframe.parentNode.removeChild(wikiIframe);
        }
    }
    wikiIframe = null;
}

function noWikiAvailable()
{
    if (alt_wikitext != null) {
        console.log("noWikiAvailable", alt_wikitext);

        document.getElementById(wiki_panel).style.height = "300px";
        document.getElementById(wiki_panel).style.width = wiki_panel_width;
        document.getElementById(wiki_panel).innerHTML = alt_wikitext;

        alt_wikitext = null;
    }
}

function getWikiContent(pageid)
{
    var url = "https://en.wikipedia.org/w/api.php?action=parse&origin=*&format=json&pageid=" + pageid;

    console.log("getWikiContent, pageid", pageid);

    document.getElementById(wiki_panel).innerHTML = null;
    document.getElementById(wiki_panel).style.height = "700px";
    document.getElementById(wiki_panel).style.width = wiki_panel_width;

    // use IFRAME and mobile wiki page
    wikiReset();

    console.log("getWikiContent, create new IFRAME");
    wikiIframe = document.createElement("IFRAME");
    wikiIframe.width = wiki_frame_width;
    wikiIframe.height = 700;
    console.log("getWikiContent, set IFRAME src", "https://en.m.wikipedia.org/?curid="+pageid);
    wikiIframe.setAttribute("src", "https://en.m.wikipedia.org/?curid="+pageid);
    document.getElementById(wiki_panel).appendChild(wikiIframe);
}

function charIsNumber(c)
{
    return c >= '0' && c <= '9';
}

function reformatCheckName(target, prefix, name)
{
    var c = target.substr(0, prefix.length).toUpperCase();
    var cn = target.substr(prefix.length, 1);
    if (c == prefix.toUpperCase() && (cn == ' ' || charIsNumber(cn))) {
        return name + ' ' + target.substr(prefix.length);
    } else {
        return null;
    }

}

// reformat target name so it is more likely found from Wikipedia
function reformatTargetName(name)
{
    var newname = reformatCheckName(name, 'M', 'Messier');
    if (newname == null) {
        // ensure correct case
        newname = reformatCheckName(name, 'Messier', 'Messier');
    }
    if (newname == null) {
        newname = reformatCheckName(name, 'NGC', 'NGC');
    }
    if (newname == null) {
        newname = reformatCheckName(name, 'IC', 'IC');
    }
    if (newname == null) {
        newname = name;
    }
    newname = trim_spaces(newname);
    console.log("reformatTargetName", name, newname);

    return newname;
}

function showWikiTarget(wiki_target)
{
    if (!document.getElementById("wikiCheckbox").checked) {
        wikiReset();
        noWikiAvailable();
        return;
    }
    var url = "https://en.wikipedia.org/w/api.php?action=query&redirects&" +
              "format=json&formatversion=2&prop=revisions&origin=*&titles=";

    wiki_target = reformatTargetName(wiki_target);
    var wiki_url = url + wiki_target.replace(/ /g, "%20");

    console.log("showWikiTarget", wiki_target, wiki_url);

    fetch(wiki_url)
        .then(
            function(response) {
                if (response.status !== 200) {
                    console.log('Problem accessing Wiki. Status Code: ' + response.status);
                    return;
                }
                response.json().then(function(jsonData) {
                    console.log('showWiki, get page id, got response from HTTP GET');
                    var pageid = jsonData.query.pages[0].pageid;
                    if (pageid) {
                        getWikiContent(pageid);
                    } else {
                        console.log("Failed to get Wiki page id from json");
                        wikiReset();
                        noWikiAvailable();
                    }
                })
            }
        )
        .catch(function(err) {
            console.log('Problem accessing Wiki. Fetch Error :', err);
        }
    );
}

function showWiki()
{
    if (!document.getElementById("wikiCheckbox").checked) {
        console.log("showWiki:do not show");
        document.getElementById(wiki_panel).style.height = "0px";
        document.getElementById(wiki_panel).style.width = "0px";
        wikiReset();
        return;
    }
    console.log("showWiki");

    var wiki_target;
    var c = image_target.substr(0,1);
    if ((c >= '0' && c <= '9') || c == '-' || c == '+') {
        // numeric target, check if we have slooh target selected
        console.log("showWiki, numeric, try current_catalog");
        if (catalog_index != null && current_catalog_filtered_list != null) {
            var name = current_catalog_filtered_list.list[catalog_index][0];
            console.log("showWiki, use current_catalog_filtered_list", name);
            wiki_target = reformatTargetName(name);
        } else {
            console.log("showWiki, no current catalog target, remove wiki");
            if (wikiIframe != null) {
                //document.getElementById(wiki_panel).removeChild(wikiIframe);
                wikiIframe = null;
            }
            return;
        }
    } else {
        console.log("showWiki, use image_target", image_target);
        wiki_target = reformatTargetName(image_target);
    }

    showWikiTarget(wiki_target);
}

// Seeing widget from https://www.meteoblue.com/
function showWeatherForecast(telescope_location_chile)
{
    if (current_telescope.weather == null) {
        return;
    }
    if (current_telescope.weather_url == null) {
        for (var i = 0; i < weather_services.length; i++) {
            if (weather_services[i].name == current_telescope.weather) {
                current_telescope.weather_url = weather_services[i].url;
            }
        }
    }
    // Add a delay before showing weather, otherwise it will be shown
    // first and screen jumps up and down
    setTimeout(function(){ 
        document.getElementById(weather_panel).style.height = "700px";
        document.getElementById(weather_panel).style.width = "600px";
        document.getElementById(weather_panel).innerHTML = current_telescope.weather_url;
    }, 1000);
}

</script>
</body>
</html>