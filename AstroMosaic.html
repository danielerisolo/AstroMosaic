<!-- Tool to visualize Slooh telescope FoV and mosaic grid. Jarmo Ruuth, 2018 -->
<!DOCTYPE HTML>
<html lang = "en">
<head>
<!-- include Aladin Lite CSS file in the head section of your page -->
<link rel="stylesheet" href="https://aladin.u-strasbg.fr/AladinLite/api/v2/latest/aladin.min.css" />
<style>
.flex-container {
  display: flex;
  flex-direction: row;
}
.flex-container > div {
  margin: 5px;
  padding: 5px;
  font-size: 20px;
}
</style>
    <title>AstroMosaic</title>
    <meta charset = "UTF-8" />
</head>

<body>
<script type="text/javascript" src="https://code.jquery.com/jquery-1.12.1.min.js" charset="utf-8"></script>
<script type="text/javascript" src="https://aladin.u-strasbg.fr/AladinLite/api/v2/latest/aladin.min.js" charset="utf-8"></script>

<h2 id="astro_mosaic_title" >Astro Mosaic for Slooh telescopes</h2>

<div class="flex-container">
    <div>
        <form action="javascript:ViewImage()">
            Target:<br>
            <input type="text" id="target"><br>
        </form>
    </div>
    <div>
        <form>
            Telescope:<br>
            <select id="telescope" onchange="javascript:ViewImage()">
                <option value="T1">T1</option>
                <option value="T2">T2</option>
                <option value="T2UWF">T2 UWF</option>
                <option value="T3">T3</option>
                <option value="T4">T4</option>
                <option value="C1">C1</option>
                <option value="C1UWF">C1 UWF</option>
            </select>
        </form>
    </div>
    <div>
        <form>
            View:<br>
            <select id="grid_type" onchange="javascript:ViewImage()">
                <option value="fov">FoV</option>
                <option value="mosaic">Mosaic grid</option>
                <option value="panels">Mosaic panels</option>
            </select>
        </form>
    </div>
    <div>
        <form action="javascript:ViewImage()">
            Mosaic overlap (%):<br>
            <input type="number" id="overlap_percentage" min="1" max="100">
        </form>    
    </div>
    <div>
        <form action="javascript:ViewImage()">
            Date (YYYY-MM-DD):<br>
            <input type="text" id="view_date">
        </form>    
    </div>
    <div>
        <br>
        <button onclick="ViewImage()">View image</button>
    </div>
    <div>
        <small id="status_text"></small>
    </div>
</div>

<div class="flex-container">
    <div>
    <!-- insert this snippet where you want Aladin Lite viewer to appear and after the loading of jQuery -->
    <div id="aladin-lite-div-0" style="width:300px;height:300px;"></div>
    <br>
    <small id="panel_text_0"></small>
    </div>
    <div>
    <!-- insert this snippet where you want Aladin Lite viewer to appear and after the loading of jQuery -->
    <div id="aladin-lite-div-1" style="width:300px;height:300px;"></div>
    <br>
    <small id="panel_text_1"></small>
    </div>
    <div>
    <!-- insert this snippet where you want Aladin Lite viewer to appear and after the loading of jQuery -->
    <div id="aladin-lite-div-2" style="width:300px;height:300px;"></div>
    <br>
    <small id="panel_text_2"></small>
    </div>
    </div>
    <div class="flex-container">
    <div>
    <!-- insert this snippet where you want Aladin Lite viewer to appear and after the loading of jQuery -->
    <div id="aladin-lite-div-3" style="width:300px;height:300px;"></div>
    <br>
    <small id="panel_text_3"></small>
    </div>
    <div>
    <!-- insert this snippet where you want Aladin Lite viewer to appear and after the loading of jQuery -->
    <div id="aladin-lite-div-4" style="width:300px;height:300px;"></div>
    <br>
    <small id="panel_text_4"></small>
    </div>
    <div>
    <!-- insert this snippet where you want Aladin Lite viewer to appear and after the loading of jQuery -->
    <div id="aladin-lite-div-5" style="width:300px;height:300px;"></div>
    <br>
    <small id="panel_text_5"></small>
    </div>
    </div>
    <div class="flex-container">
    <div>
    <!-- insert this snippet where you want Aladin Lite viewer to appear and after the loading of jQuery -->
    <div id="aladin-lite-div-6" style="width:300px;height:300px;"></div>
    <br>
    <small id="panel_text_6"></small>
    </div>
    <div>
    <!-- insert this snippet where you want Aladin Lite viewer to appear and after the loading of jQuery -->
    <div id="aladin-lite-div-7" style="width:300px;height:300px;"></div>
    <br>
    <small id="panel_text_7"></small>
    </div>
    <div>
    <!-- insert this snippet where you want Aladin Lite viewer to appear and after the loading of jQuery -->
    <div id="aladin-lite-div-8" style="width:300px;height:300px;"></div>
    <br>
    <small id="panel_text_8"></small>
    </div>
</div>

<footer>
    <small>Author: Jarmo Ruuth. Send feedback to: <a href="mailto:astromosaicxyz@gmail.com">
        astromosaicxyz@gmail.com</a>.</small>
</footer>

<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
<script type="text/javascript">

// size means number of panels on each side
// 1 gives 3x3
var size = 1;

var telescope = "T1";
var fov_x;
var fov_y;
var img_fov = 0.8;  // field of view for single image considering the overlap
var img_size = 300;
var image_target;

var UTCdate_ms;

var url = new URL(window.location);
console.log(url);

var url_target = null;
var url_telescope = null;
var url_name = null;
var url_type = null;
var url_overlap = null;
var url_date = null;

if (typeof URLSearchParams === "function") {
    searchParams = new URLSearchParams(url.search.slice(1));
    url_target = searchParams.get('target');
    url_telescope = searchParams.get('telescope');
    url_name = searchParams.get('name');
    url_type = searchParams.get('type');
    url_overlap = searchParams.get('overlap');
    url_date = searchParams.get('date');
}

var xmlhttp;
var resolved_name = null;
var resolved_coordinates = null;

var target_ra;
var target_dec;
var location_lat;
var location_lng;
var location_alt;

var hour_ms = 60*60*1000;
var day_ms = 24*hour_ms;
var degToRad = Math.PI/180.0;
var radToDeg = 180.0/Math.PI;
var degToHours = 1/15;
var hoursToDeg = 15;
var JD1970 = 2440587.5;     // JD 1970-01-01 00:00 - Javascrip zero time

if (!url_target) {
    url_target = "Horsehead nebula";
}

if (url_name) {
    document.getElementById("astro_mosaic_title").innerHTML = url_name;
}
if (url_telescope) {
    document.getElementById("telescope").value = url_telescope;
}
if (url_type) {
    document.getElementById("grid_type").value = url_type;
}
if (url_overlap) {
    document.getElementById("overlap_percentage").value = url_overlap;
} else {
    document.getElementById("overlap_percentage").value = 20;
}
if (url_date) {
    document.getElementById("view_date").value = url_date;
} else {
    var d = new Date();
    document.getElementById("view_date").value = d.toISOString().substr(0, 10);
}

if (url_target) {
    document.getElementById("target").value = url_target;
    ViewImage();
}

// convert image_target HH:MM:SS DEG:HH:MM to decimal dgrees in target_ra and target_dec
function get_target_ra_dec()
{
        // assume format HH:MM:SS DEG:HH:MM
        var radec = image_target.split(' ');
        
        var raparts = radec[0].split(':');
        var decparts = radec[1].split(':');

        target_ra = Math.abs(parseFloat(raparts[0])) + (parseFloat(raparts[1]) * 60 + parseFloat(raparts[2])) / 3600;
        // convert from hours to degrees
        target_ra = target_ra * hoursToDeg;
        if (parseFloat(raparts[0]) < 0) {
            target_ra = -target_ra;
        }
        target_dec = Math.abs(parseFloat(decparts[0])) + (parseFloat(decparts[1]) * 60 + parseFloat(decparts[2])) / 3600;
        if (parseFloat(decparts[0]) < 0) {
            target_dec = -target_dec;
        }
}

// scale degrees to 0-360
function scale_to_360(v)
{
    while (v < 0) {
        v = v + 360;
    }
    return v - Math.floor(v/360)*360;
}

// sin from decimal degrees
function sind(deg)
{
    return Math.sin(deg*degToRad);
}

// cos from decimal regrees
function cosd(deg)
{
    return Math.cos(deg*degToRad);
}

// Julian Days from 2000, including fraction, used by sun and moon calculations
function getJD(d)
{
    var days = JD1970 + d / day_ms - 2451543.5;
    return days;
}

// Days from J2000, including fraction, used by altitude calculations
function getJ2000_2(d)
{
    var days = JD1970 + d / day_ms - 2451545.0;
    return days;
}

// Calculate object altitude. 
// Useful links:
//      https://astronomy.stackexchange.com/questions/24859/local-sidereal-time
//      https://observability.date/notes
//      http://njsas.org/projects/tidal_forces/altaz/pausch/riset.html
//      http://www.stjarnhimlen.se/comp/tutorial.html
function object_altitude(date, ra, dec, lat, lng)
{
    // universal time in decimal hours
    var H = (date % day_ms) / hour_ms;

    // Julian date including fraction - 2451545.0,
    // that is days from J2000
    var D = getJ2000_2(date);

    // calculate local sidereal time in degrees
    var LST = 100.4606184 + 0.9856473662862 * D + H * hoursToDeg + lng;

    // get hours
    LST = LST % 360;

    // calculate local hour angle in degrees
    var LHA = LST - ra;

    // calculate sin(altitude) in radian
    var sin_altitude = sind(lat) * sind(dec) + cosd(lat) * cosd(dec) * cosd(LHA);

    var altitude = Math.asin(sin_altitude) * radToDeg;

    //console.log("object_altitude, last=",LST*degToHours,",lha=",LHA*degToHours,",sinalt=",sin_altitude,",alt=",altitude,",H=",H);

    return altitude;
}

// Simplified version of moon position at given time.
// - there are a lot of variables that affect correct moon position that
//    are ignored here
// - we do not correct for altitude
// Links:
//      http://www.stjarnhimlen.se/comp/tutorial.html
function moon_position(date)
{
    // Days from J2000
    var d = getJD(date);
    var pi = Math.PI;
    var nloop;
    //console.log("moon position d=",d,"JD=",JD1970+d/day_ms);

    var N = scale_to_360(125.1228 - 0.0529538083 * d);
    var i = 5.1454;
    var w = scale_to_360(318.0634 + 0.1643573223 * d);
    var a = 60.2666;
    var e = 0.054900;
    var M = scale_to_360(115.3654 + 13.0649929509 * d);
    //console.log("N",N,"i",i,"w",w,"a",a,"e",e,"M",M);

    var E = M + e*(180/pi) * sind(M) * ( 1.0 + e * cosd(M) );
    for (nloop = 0; nloop < 100; nloop++) {
        var E0 = E;
        E = E0 - (E0 - e * (180/pi) * sind(E0) - M) / (1- e * cosd(E0));
        if (Math.abs(E-E0) <= 0.001) {
            break;
        }
    }
    //console.log("E", E, "nloop", nloop);

    var x = a * ( cosd(E) - e );
    var y = a * Math.sqrt(1.0 - e*e) * sind(E);
    //console.log("x,y",x,y);

    var r = Math.sqrt( x*x + y*y );
    var v = scale_to_360(Math.atan2( y, x ) * radToDeg);
    //console.log("r,v",r,v);

    // moon geocentric position in ecliptic coordinates
    var xeclip = r * ( cosd(N) * cosd(v+w) - sind(N) * sind(v+w) * cosd(i) );
    var yeclip = r * ( sind(N) * cosd(v+w) + cosd(N) * sind(v+w) * cosd(i) );
    var zeclip = r * ( sind(v+w) * sind(i) );
    //console.log("moon xeclip=",xeclip,",yeclip=",yeclip,",zeclip=",zeclip);

    // ecliptic longitude and latitude
    //var lonecl = scale_to_360(Math.atan2( yeclip, xeclip ) * radToDeg);
    //var latecl = Math.atan2( zeclip, Math.sqrt(xeclip*xeclip+yeclip*yeclip) ) * radToDeg;
    //console.log("lonecl,latecl",lonecl,latecl);

    var oblecl = 23.4;

    // rotate ecliptic coordinates to equatorial coordinates
    var xequat = xeclip;
    var yequat = yeclip * cosd(oblecl) - zeclip * sind(oblecl);
    var zequat = yeclip * sind(oblecl) + zeclip * cosd(oblecl);
    //console.log("moon xequat=",xequat,",yequat=",yequat,",zequat=",zequat);

    // calculate RA and Dec
    var RA  = scale_to_360(Math.atan2( yequat, xequat ) * radToDeg);
    var Dec = Math.atan2( zequat, Math.sqrt(xequat*xequat+yequat*yequat) ) * radToDeg;

    //console.log("moon ra",RA,",dec",Dec);

    return {ra:RA, dec:Dec};
}

// a simple version for topocentric correction
function moon_topocentric_correction(alt)
{
    var r = 60.336;
    return alt - Math.asin(1/r) * cosd(alt);
}

// Sun position at given time.
// Links:
//      http://www.stjarnhimlen.se/comp/tutorial.html
function sun_position(date)
{
    // Days from J2000
    var d = getJD(date);
    var pi = Math.PI;
    //console.log("sun_position d", d);

    var w = scale_to_360(282.9404 + 4.70935E-5 * d);
    var a = 1.0;
    var e = 0.016709 - 1.151E-9 * d;
    var M = scale_to_360(356.0470 + 0.9856002585 * d);

    //console.log(w,a,e,M);

    var oblecl = scale_to_360(23.4393 - 3.563E-7 * d);
    var L = scale_to_360(w + M);
    //console.log("L", L,"oblecl", oblecl);

    var E = scale_to_360((M + (180/pi) * e * sind(M) * (1 + e * cosd(M))));
    //console.log("E", E);

    var x = cosd(E) - e;
    var y = sind(E) * Math.sqrt(1 - e*e);
    //console.log("x,y", x,y);

    var r = Math.sqrt(x*x + y*y);
    var v = Math.atan2( y, x ) * radToDeg;
    //console.log("r,v", r,v);

    var lon = scale_to_360(v + w);
    //console.log("lon", lon);

    x = r * cosd(lon);
    y = r * sind(lon);
    //console.log("x,y", x,y);

    var xequat = x;
    var yequat = y * cosd(oblecl);
    var zequat = y * sind(oblecl);
    //console.log("xequat,yequat", xequat,yequat);

    var RA  = Math.atan2( yequat, xequat ) * radToDeg;
    var Dec = Math.atan2( zequat, Math.sqrt(xequat*xequat+yequat*yequat) ) * radToDeg;

    console.log("Sun_position", RA, Dec);

    return {ra:RA, dec:Dec};
}

// Simplified version of rise and set times.
// - we do not correct for altitude
// - we use current day rise time as next day rise time
// Links:
//      http://www.stjarnhimlen.se/comp/tutorial.html
function sun_rise_set(midday, lat, lon, h)
{
    var d = getJD(midday);
    
    var sun_pos = sun_position(midday);
    var LST = sun_pos.ra;

    var w = scale_to_360(282.9404 + 4.70935E-5 * d);
    var M = scale_to_360(356.0470 + 0.9856002585 * d);
    var L = M + w;
    var GMST0 = scale_to_360(L + 180);

    var UT_sun = (LST - GMST0 - lon) * degToHours;
    if (UT_sun < 0) {
        UT_sun = UT_sun + 24;
    }
    //console.log("Sun_rise_set UT_sun", UT_sun);

    // calculate midday at location
    midday = midday - 12 * hour_ms + UT_sun * hour_ms;

    var cos_LHA = (sind(h) - sind(lat)*sind(sun_pos.dec)) / (cosd(lat) * cosd(sun_pos.dec));

    var LHA = (Math.acos(cos_LHA) * radToDeg) * degToHours;
    //console.log("Sun_rise_set LHA", LHA);

    //console.log("Sun_rise_set set rise", 12+LHA, 12-LHA);

    // we use the current day sunrise as the next sunrise which is not exactly correct
    return {sunset: midday + LHA*hour_ms, sunrise: midday - LHA*hour_ms + day_ms};
}

// Calculate distance in degrees between two (ra,dec) positions
function moon_distance(ra1, dec1, ra2, dec2)
{
    var cos_A = sind(dec1) * sind(dec2) + cosd(dec1) * cosd(dec2) * cosd(ra1 - ra2);
    var A = Math.acos(cos_A) * radToDeg;
    if (A < 0) {
        A = -A;
    }
    if (A > 180) {
        A = 360 - A;
    }
    return A;
}

// This method can be found in many places, somwhow
// it gives weird results
function get_moon_phase2(date)
{
    var d = getJD(date);

    var v = (d-2451550.1) / 29.530588853;
    v = v - Math.floor(v);
    if (v < 0) {
        v = v + 1;
    }

    var age = v * 29.53;
    return age;
}

// My own version, calcuate sun-moon angle to get
// approximate "phase" in percentages
function get_moon_phase(d)
{
    var sunpos = sun_position(d);
    var moonpos = moon_position(d);
    var dist = moon_distance(sunpos.ra, sunpos.dec, moonpos.ra, moonpos.dec);
    //console.log("get_moon_phase dist", dist);
    return (scale_to_360(dist) / 180) * 100;
}

// Convert to dtate string to that e.g. 1:0 becomes 01:00
function toDateString(num)
{
    if (num < 10) {
        return '0' + num.toString();
    } else {
        return num.toString();
    }
}

function drawDayVisibilityandGrid() 
{
    console.log("drawDayVisibilityandGrid");

    ViewGrid();

    var data = new google.visualization.DataTable();
    // get midday in UTC time in ms
    var midday = UTCdate_ms + day_ms/2;
    var UTCmidday = new Date(midday);

    //data.addColumn('datetime', 'Time'); Can't get this working...
    data.addColumn('string', 'Time');
    //data.addColumn('datetime', 'Time');
    data.addColumn('number', 'Alt >= 30');         // object altitude
    data.addColumn('number', 'Alt < 30');     // object altitude if below 30 degrees
    data.addColumn('number', 'Moon alt');           // moon altitude

    var interval = day_ms/(24*6); // 10 minutes
    
    var ra = target_ra;
    var dec = target_dec;
    
    var lat = location_lat;
    var lng = location_lng;

    var rowdata = [];

    var draw_full_day = 0;  // if 0 draw only during astronimical twilight

    // sun rise and set times at astronomical twilight at -15 degrees
    suntimes = sun_rise_set(midday, lat, lng, -12);

    var UTCsunset = new Date(suntimes.sunset);
    var UTCsunrise = new Date(suntimes.sunrise);
    var prevalt = null;

    var starttime;
    var endtime;
    if (draw_full_day) {
        starttime = midday;
        endtime = starttime + day_ms;
    } else {
        starttime = suntimes.sunset - suntimes.sunset % interval;
        endtime = suntimes.sunrise + interval - suntimes.sunrise % interval;
    }

    for (var d = starttime; d <= endtime; d = d + interval) {
        //console.log("d",d,"sunrise",suntimes.sunrise,"unset",suntimes.sunset);
        var objectalt = object_altitude(d, ra, dec, lat, lng);

        var moonpos = moon_position(d);
        var moonalt = object_altitude(d, moonpos.ra, moonpos.dec, lat, lng);
        moonalt = moon_topocentric_correction(moonalt);
        var UTCdate = new Date(d);
        //console.log("i=",i,",d=",d,",alt=", altdata, ",moonalt=",moonalt);

        // When object is below 30 dgrees it is too low for proper imaging.
        // we fraw a different line (different color) when object is below
        // 30 degrees (objectlowalt).
        var objecthighalt = objectalt;
        var objectlowalt = null;
        if (objectalt < 0) {
            objecthighalt = null;
        } else if (objectalt < 30) {
            if (prevalt != null && prevalt >= 30) {
                // close the gap, coming down
                objectlowalt = objectalt;
                //console.log("close the gap down", rowdata.length-1);
            } else {
                objectlowalt = objectalt;
                objecthighalt = null;
            }
        } else {
            if (prevalt != null && prevalt < 30) {
                // close the gap
                rowdata[rowdata.length-1][1] =  prevalt;
                //console.log("close the gap up", rowdata.length-1);
            }
        }
        prevalt = objectalt;
        if (moonalt < 0) {
            moonalt = null;
        }
        var row = [
                    toDateString(UTCdate.getUTCHours())+":"+toDateString(UTCdate.getUTCMinutes()), 
                    //UTCdate,
                    objecthighalt,
                    objectlowalt,
                    moonalt];
        //console.log("row", row);
        rowdata[rowdata.length] = row;
    }

    //for (var i = 0; i < rowdata.length; i++) {
    //    console.log("rowdata", i, rowdata[i])
    //}

    data.addRows(rowdata);

    // problems with timezone if using date, formatter does not solve all problems
    //var formatter = new google.visualization.DateFormat({timeZone: 0});
    //formatter.format(data, 0);

    var options = {
        title: 'Target visibility',
        hAxis: { 
            title: 'Time (UTC)'
            //format: 'HH:mm' 
        },
        vAxis: { title: 'Altitude (degrees)' },
        gridlines: {    // Can't get gridlines to work...
            // count: -1
            //units: { hours: {format: ['HH:MM']}, }
        },
        // minorGridlines: { units: { hours: {format: ['HH:MM']} } },
        series: { 
            0: { color: 'blue' },
            1: { color: 'orange' },
            2: { color: 'green', lineDashStyle: [4, 4] }
        }
    };

    document.getElementById("aladin-lite-div-3").style.height = "400px";
    document.getElementById("aladin-lite-div-3").style.width = "700px";

    // material var chart = new google.charts.Line(document.getElementById('aladin-lite-div-3'));
    var chart = new google.visualization.LineChart(document.getElementById('aladin-lite-div-3'));

    // material chart.draw(data, google.charts.Line.convertOptions(options));
    chart.draw(data, options);

    var midnight = suntimes.sunset + (suntimes.sunrise - suntimes.sunset) / 2;

    // We use sun and moon distance in dgrees at midnight to approximate 
    // the moon "phase". I guess there is also a correct way...
    var moon_phase = get_moon_phase(midnight);
    // Moon distance from object at midnight. Distance changes during the night
    // but not much so this should be fine.
    var moonpos_midnight = moon_position(midnight);
    var moon_angle = moon_distance(ra, dec, moonpos_midnight.ra, moonpos_midnight.dec);

    document.getElementById("panel_text_3").innerHTML = 
        //"Astronomical twilight start : " + UTCsunset.toUTCString() + "<br>" +
        //"Astronomical twilight end : " + UTCsunrise.toUTCString() + "<br>" +
        "Moon phase: " + Math.floor(moon_phase) + "%<br>" +
        "Moon distance from target: " + Math.floor(moon_angle) + " degrees";

    //console.log("TEST 1990-04-19");
    //moon_position(Date.UTC(1990, 3, 19));
}

function drawYearVisibility() 
{
    console.log("drawYearVisibility");

    var data = new google.visualization.DataTable();
    // get midday in UTC time in ms
    var midday = UTCdate_ms + day_ms/2;

    //data.addColumn('datetime', 'Time'); Can't get this working...
    data.addColumn('date', 'Date');
    data.addColumn('number', 'Target alt');         // object altitude
    data.addColumn('number', 'Moon alt');           // moon altitude

    var interval = day_ms; // day
    
    var ra = target_ra;
    var dec = target_dec;
    
    var lat = location_lat;
    var lng = location_lng;

    var rowdata = [];

    var starttime = midday;
    var endtime = starttime + 365 * day_ms;

    for (var d = starttime; d <= endtime; d = d + interval) {
        var suntimes = sun_rise_set(d, lat, lng, 0);

        // get appriximate midnight
        var midnight = suntimes.sunset + (suntimes.sunrise - suntimes.sunset) / 2;

        var objectalt = object_altitude(midnight, ra, dec, lat, lng);

        var moonpos = moon_position(midnight);
        var moonalt = object_altitude(midnight, moonpos.ra, moonpos.dec, lat, lng);
        moonalt = moon_topocentric_correction(moonalt);
        if (objectalt < 0) {
            objectalt = null;
        }
        if (moonalt < 0) {
            moonalt = null;
        }
        var row = [
                new Date(d),
                    objectalt,
                    moonalt];
        rowdata[rowdata.length] = row;
    }

    data.addRows(rowdata);

    var options = {
        title: 'Target visibility at midnight over next 12 months',
        hAxis: { 
            //title: 'Date'
            //format: 'HH:mm' 
        },
        vAxis: { title: 'Altitude (degrees)' },
        gridlines: {    // Can't get gridlines to work...
            // count: -1
            //units: { hours: {format: ['HH:MM']}, }
        },
        // minorGridlines: { units: { hours: {format: ['HH:MM']} } },
        series: { 
            0: { color: 'blue' },
            1: { color: 'green', lineDashStyle: [4, 4] }
        }
    };

    document.getElementById("aladin-lite-div-6").style.height = "400px";
    document.getElementById("aladin-lite-div-6").style.width = "700px";

    var chart = new google.visualization.LineChart(document.getElementById('aladin-lite-div-6'));

    chart.draw(data, options);
}

// Find coordinates from Sesame XML output
// or SIMBAD ascii output
function find_coordinates(str)
{
    console.log('find_coordinates');

    var idx = str.indexOf("<jpos>");
    if (idx > 0) {
        // Assume Sesame XML format
        var coord = str.substr(idx+6, 100);
        var idx2 = coord.indexOf("</jpos>");
        if (idx2 == -1) {
            console.log("find_coordinates:failed to get coordinates from '", coord, "', failed at position ", i.toString());
            return false;
        }
        image_target = coord.substr(0, idx2);
    } else {
        // Simbad ascii output
        idx = str.indexOf("J2000");
        if (idx == -1) {
            console.log("find_coordinates:could not find 'J2000'");
            return false;
        }
        str = str.substr(idx+4);
        idx = str.indexOf(":");
        if (idx == -1) {
            console.log("find_coordinates:could not find ':'");
            return false;
        }
        var coord = str.substr(idx+1, 100);
        console.log("find_coordinates:get coordinates from '", coord, "'");
        coord = trim_spaces(coord);
        for (var i = 0; i < coord.length; i++) {
            var c = coord.substr(i,1);
            if ((c < '0' || c > '9') && c != '.' && c != '-' && c != '+' && c != ' ') {
                break;
            }
        }
        if (i < 12) {
            console.log("find_coordinates:failed to get coordinates from '", coord, "', failed at position ", i.toString());
            return false;
        }
        image_target = coord.substr(0, i);
    }
    resolved_name = image_target;

    // change image_target from name to coordinates
    image_target = trim_spaces(image_target);
    console.log("find_coordinates:image_target=", image_target);
    image_target = reformat_coordinates(image_target);
    document.getElementById("status_text").innerHTML = "RA/DEC<br>" + image_target;

    resolved_coordinates = image_target;

    return true;
}

// Resolve image coordinates from Simbad database using name
function ViewImageByName()
{
    console.log('ViewImageByName');

    if (resolved_name == image_target && resolved_coordinates != null) {
        // same name already resolved, do not resolve again
        document.getElementById("status_text").innerHTML = "RA/DEC<br>" + resolved_coordinates;
        image_target = resolved_coordinates;
        ViewImageByType();
        return;
    }

    // Simbad ascii, some problems when accessing the site
    // var resolver_url = "https://simbad.u-strasbg.fr/simbad/sim-id?output.format=ASCII&Ident=";
    
    // Mirror of Simbad u-strasbg? Worked when u-strasbg failed.
    // var resolver_url = "http://simbad.cfa.harvard.edu/simbad/sim-id?output.format=ASCII&Ident=";

    // Sesame  uses Simbad, NED and Vizier for resolving. Best documented interface.
    var resolver_url = "https://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame/-oxp/SNV?";

    xmlhttp=new XMLHttpRequest();
    xmlhttp.onreadystatechange=function()
    {
        if (xmlhttp.readyState==4 && xmlhttp.status==200) {
            console.log('simbad_resolve, got response from HTTP GET: ', xmlhttp.responseText.substr(0, 40));
            if (find_coordinates(xmlhttp.responseText)) {
                ViewImageByType();
            } else {
                document.getElementById("status_text").innerHTML = "<br>Failed to resolve name " + image_target;
            }
        }
    }
    resolver_url = resolver_url + image_target.replace(/ /g, "+");
    console.log('ViewImageByName, send HTTP GET(' + resolver_url + ')');
    xmlhttp.open("GET", resolver_url, false);
    xmlhttp.send();    
}

// Remove leading, trailing and duplicate spaces
function trim_spaces(str)
{
    // replace all whitespace to space
    str = str.replace(/\s/g, " ");
    // remove leading and trailing spaces
    str = str.trim();
    for (var i = 0; i < str.length && str.indexOf('  ') != -1; i++) {
        // remove all duplicate spaces
        str = str.replace(/  /g, " ");
    }
    return str;
}

// Reformat coordinates to a format HH:MM:SS DD:MM:SS
// Input can be: 
// HH:MM:SS DD:MM:SS, HH MM SS DD MM SS, 
// HH:MM:SS/DD:MM:SS, HH MM SS/DD MM SS,
function reformat_coordinates(coord)
{
    // number, assume coordinates
    coord = trim_spaces(coord);
    console.log('reformat_coordinates=', coord);
    var numbers = coord.split('/');
    if (numbers.length == 2) {
        coord = trim_spaces(numbers[0] + ' ' + numbers[1]);
        console.log('reformat_coordinates, split by /', coord);
    }
    numbers = coord.split(' ');
    console.log('reformat_coordinates, numbers.length=', numbers.length);
    if (numbers.length == 2) {
        // assume already correct format
        console.log('reformat_coordinates, length 2, assume correct format', coord);
    } else if (numbers.length == 6) {
        // separated by space, add colons
        coord = numbers[0] + ':' + numbers[1] + ':' + numbers[2] + ' ' +
                numbers[3] + ':' + numbers[4] + ':' + numbers[5];
        console.log('reformat_coordinates, length "+numbers.length+", use as-is', coord);
    } else if (numbers.length == 5) {
        // badly formatted SIMBAD case, assume zero last number, separated by space, add colons
        coord = numbers[0] + ':' + numbers[1] + ':' + numbers[2] + ' ' +
                numbers[3] + ':' + numbers[4] + ':' + 0;
        console.log('reformat_coordinates, length "+numbers.length+", use as-is', coord);
    } else {
        // use as-is
        console.log('reformat_coordinates, length 6, reformat', coord);
    }
    return coord;
}

// Main function to view image. Get parameters
// and call correct view function
function ViewImage()
{
    console.log('ViewImage');

    clearOldImage();

    // get current date
    var view_date = document.getElementById("view_date").value;
    var curdate = new Date(view_date);
    if (curdate == null || isNaN(curdate.valueOf())) {
        document.getElementById("status_text").innerHTML = "<br>Invalid ISO format date " + view_date;
        return;
    }
    //console.log("curdate", curdate);
    UTCdate_ms = Date.UTC(parseInt(view_date.substr(0, 4)), parseInt(view_date.substr(5, 2))-1, 
                          parseInt(view_date.substr(8, 2)));


    img_fov = document.getElementById("overlap_percentage").value;
    img_fov = 1 - img_fov / 100;

    telescope = document.getElementById("telescope").value;

    // assume Teide, both in degrees
    var location = 'teide';
    location_lat = 28.29970;        // N28.29970 (N28° 17′ 58.92″)
    location_lng = -16.50826;       // W016.50826 (W016° 30′ 29.736″)
    location_alt = 2372;

    // T1 FOV 37´
    // T2 wide field FOV 43'
    // T2 ultra wide field FOV 1° 47' 06" x 1° 12' 12"
    // T3 FOV 1.654° x 1.249°
    // T4 FOV 0° 15' 57" x 0° 12' 03"
    // C1 FOV 0° 31' 18" x 0° 20' 51"
    // C1 ultra wide field FOV 1° 21' 49" x 1° 00' 22"

    if (telescope == "T1") {
        fov_x = 37.0*60.0/3600.0;
        fov_y = 37.0*60.0/3600.0;
    } else if (telescope == "T2") {
        fov_x = 43.0*60.0/3600.0;
        fov_y = 43.0*60.0/3600.0;
    } else if (telescope == "T2UWF") {
        fov_x = 1+(47.0*60.0+6.0)/3600.0;
        fov_y = 1+(12.0*60.0+12.0)/3600.0;
    } else if (telescope == "T3") {
        fov_x = 1.654;
        fov_y = 1.249;
    } else if (telescope == "T4") {
        fov_x = (15*60.0+57)/3600.0;
        fov_y = (12*60.0+3)/3600.0;
    } else if (telescope == "C1") {
        fov_x = (31*60.0+18)/3600.0; 
        fov_y = (20*60.0+51)/3600.0;
        location = 'chile';
    } else if (telescope == "C1UWF") {
        fov_x = 1+(21*60.0+49)/3600.0; 
        fov_y = 1+22/3600.0;
        location = 'chile';
    }

    if (location == 'chile') {
        // Chile location in degrees
        location_lat = -33.269;         // S33.269 (S33° 16' 8.4")
        location_lng = -70.534;         // W070.534 (W070° 32' 2.4")
        location_alt = 1450;
    }

    document.getElementById("status_text").innerHTML = "";

    image_target = document.getElementById("target").value;
    image_target = trim_spaces(image_target);
    console.log('target=', image_target);
    var c = image_target.substr(0,1);
    if ((c >= '0' && c <= '9') || c == '-' || c == '+') {
        image_target = reformat_coordinates(image_target);
        ViewImageByType();
    } else {
        // try to resolve target as a name
        ViewImageByName();
    }
}

function ViewImageByType()
{
    console.log('ViewImageByType');
    if (document.getElementById("grid_type").value == 'panels') {
        ViewPanels();
    } else {
        get_target_ra_dec();

        // material google.charts.load('current', {'packages':['line']});
        google.charts.load('current', {'packages':['corechart']});
        google.charts.setOnLoadCallback(drawDayVisibilityandGrid);
        google.charts.setOnLoadCallback(drawYearVisibility);
    }
}

function degrees_to_radians(degrees)
{
    var pi = Math.PI;
    return degrees * (pi/180);
}

function clearOldImage()
{
    for (var i = 0; i < 9; i++) {
        var panel_number = i + 1;
        document.getElementById("aladin-lite-div-"+i.toString()).innerHTML = "";
        document.getElementById("aladin-lite-div-"+i.toString()).style.borderStyle = "none";;
        document.getElementById("panel_text_"+i.toString()).innerHTML = "";
    }
}

function ViewGrid()
{
    console.log('ViewGrid');

    document.getElementById("aladin-lite-div-0").style.height = "700px";
    document.getElementById("aladin-lite-div-0").style.width = "700px";

    grid_type = document.getElementById("grid_type").value;

    // Show image and get coordinates from there to
    // calculate grid boxes.
    var aladin_fov;
    if (grid_type == "mosaic") {
        aladin_fov = 3.2*fov_x;
    } else {
        aladin_fov = 1.2*fov_x;
    }
    var aladin = A.aladin('#aladin-lite-div-0', {survey: "P/DSS2/color", fov:aladin_fov, target:image_target,
                           showReticle:false, showZoomControl:false, showFullscreenControl:false, 
                           showLayersControl:false, showGotoControl:false, 
                           showControl: false, cooFrame: "J2000", showFrame: false});
    var radec = aladin.getRaDec();

    console.log("cented RaDec = ", radec);

    var ra = radec[0];
    var dec = radec[1];

    var i = 0;
    var row = size;
    var col;
    var panel_radec;
    var fov_panel_radec;
    var panel_row = 1;
    var panel_radec2 = "";
    while (row >= -size) {
        var row_dec = dec + row * img_fov * fov_y;
        col = size;
        panel_radec = "";
        while (col >= -size) {
            var col_ra = ra + col * (img_fov * fov_x * (1/Math.cos(degrees_to_radians(Math.abs(row_dec)))));

            console.log("panel ra/dec=", col_ra, "/", row_dec);

            // now center ra/dec is col_ra/row_dec
            // calculate corners
            var row_dec1 = row_dec + fov_y/2;
            var row_dec2 = row_dec - fov_y/2;
            var col_ra1 = ra + col * (img_fov * fov_x * (1/Math.cos(degrees_to_radians(Math.abs(row_dec1)))));
            var col_ra2 = ra + col * (img_fov * fov_x * (1/Math.cos(degrees_to_radians(Math.abs(row_dec2)))));
            var col_ra1_delta = ((fov_x/2) * (1/Math.cos(degrees_to_radians(Math.abs(row_dec1)))));
            var col_ra2_delta = ((fov_x/2) * (1/Math.cos(degrees_to_radians(Math.abs(row_dec2)))));

            var panel = [
                [col_ra1-col_ra1_delta, row_dec1], 
                [col_ra1+col_ra1_delta, row_dec1], 
                [col_ra2+col_ra2_delta, row_dec2], 
                [col_ra2-col_ra2_delta, row_dec2], 
                [col_ra1-col_ra1_delta, row_dec1]
            ];

            console.log("panel = ", panel);

            var line_color = '#ee2345';

            if (grid_type == "mosaic" || i == 4) {
                var overlay = A.graphicOverlay({color: line_color, lineWidth: 2});
                aladin.addOverlay(overlay);
                overlay.add(A.polyline(panel));
            }
            col = col - 1;
            i = i + 1;

            var col_ra_hours = col_ra * degToHours;

            panel_radec = panel_radec + "P" + i.toString() + 
                          " RA/DEC " + col_ra_hours.toFixed(5) + 
                          "/" + row_dec.toFixed(5);
            if (i == 4) {
                fov_panel_radec = " RA/DEC " + col_ra_hours.toFixed(5) + 
                                  "/" + row_dec.toFixed(5);
            }
            switch (i) {
                case 1:
                case 2:
                case 4:
                case 5:
                case 7:
                case 8:
                    panel_radec = panel_radec + ' - ';
                    break;
            }
        }
        row = row - 1;
        if (grid_type == "mosaic") {
            panel_radec2 = panel_radec2 + "<br>" + panel_radec;
        }
        panel_row = panel_row + 1;
    }
    if (grid_type == "mosaic") {
        document.getElementById("panel_text_0").innerHTML = panel_radec2;
    } else {
        document.getElementById("panel_text_0").innerHTML = fov_panel_radec;
    }
}

function ViewPanels()
{
    console.log('ViewPanels');

    document.getElementById("aladin-lite-div-0").style.height = "300px";
    document.getElementById("aladin-lite-div-0").style.width = "300px";
    document.getElementById("aladin-lite-div-3").style.height = "300px";
    document.getElementById("aladin-lite-div-3").style.width = "300px";
    document.getElementById("aladin-lite-div-6").style.height = "300px";
    document.getElementById("aladin-lite-div-6").style.width = "300px";

    // First show center panel and get coordinated from there to
    // calculate other panels.
    if (fov_x != fov_y) {
        var height = 300 * fov_y / fov_x;
        document.getElementById("aladin-lite-div-4").style.height = Math.floor(height).toString() + "px";
    } else {
        document.getElementById("aladin-lite-div-4").style.height = "300px";
    }
    console.log("image_target=" + image_target);
    var aladin = A.aladin('#aladin-lite-div-4', {survey: "P/DSS2/color", fov:fov_x, target:image_target,
                           showReticle:false, showZoomControl:false, showFullscreenControl:false, 
                           showLayersControl:false, showGotoControl:false,
                           showControl: false, cooFrame: "J2000", showFrame: false});
    var radec = aladin.getRaDec();

    var ra = radec[0];
    var dec = radec[1];

    var i = 0;
    var row = size;
    var col;
    while (row >= -size) {
        var row_dec = dec + row * img_fov * fov_y;
        col = size;
        while (col >= -size) {
            var col_ra = ra + col * (img_fov * fov_x * (1/Math.cos(degrees_to_radians(Math.abs(row_dec)))));
            // convert from degrees to hours
            col_ra = col_ra * degToHours;

            var point_ra_hour = Math.floor(col_ra);
            var point_ra_sec = (Math.abs(col_ra) - Math.abs(point_ra_hour)) * 3600;
            var point_ra_min = Math.floor(point_ra_sec / 60);
            point_ra_sec = point_ra_sec - point_ra_min * 60;
    
            var point_dec_hour = Math.floor(row_dec);
            var point_dec_sec = (Math.abs(row_dec) - Math.abs(point_dec_hour)) * 3600;
            var point_dec_min = Math.floor(point_dec_sec / 60);
            point_dec_sec = point_dec_sec - point_dec_min * 60;
    
            aladin_target_str = point_ra_hour.toString() + ":" + point_ra_min.toString() + ":" + point_ra_sec.toFixed(2) + " ";
            aladin_target_str = aladin_target_str + point_dec_hour.toString() + ":" + point_dec_min.toString() + ":" + point_dec_sec.toFixed(2);

            if (i != 4) {
                var panel_id = 'aladin-lite-div-'+i.toString();
                if (fov_x != fov_y) {
                    var height = 300 * fov_y / fov_x;
                    document.getElementById(panel_id).style.height = Math.floor(height).toString() + "px";
                } else {
                    document.getElementById(panel_id).style.height = "300px";
                }
                aladin = A.aladin('#'+panel_id, {survey: "P/DSS2/color", fov:fov_x, target: aladin_target_str,
                                    showReticle:false, showZoomControl:false, showFullscreenControl:false, 
                                    showLayersControl:false, showGotoControl:false,
                                    showControl: false, cooFrame: "J2000", showFrame: false});
            }
            var panel_number = i + 1;
            document.getElementById("panel_text_"+i.toString()).innerHTML = panel_number.toString() + " RA/DEC " + col_ra.toFixed(5) + "/" + row_dec.toFixed(5);
            col = col - 1;
            i = i + 1;
        }
        row = row - 1;
    }
}

</script>
</body>
</html>
